<!DOCTYPE html>
<html>
  <head>
    <title>Start Page</title>
    <link rel="stylesheet" type="text/css" href="/index.ded19d9f.css">
  </head>
  <body>
    <div class="terminal">
      <div class="command-line"></div>
      <label for="username-input">Username:</label>
      <input type="text" id="username-input" placeholder="$" name="username-input">
      <label for="age-input">Age:</label>
      <input type="text" id="age-input" placeholder="$" age="age-input">      
      <button id="start-button">Start Game</button>
    </div>

    <script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"aid5L":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "3697770ad22d1cfe";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets, assetsToDispose, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets); // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                } // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle, id) {
    // Execute the module.
    bundle(id); // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            }); // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"9UgBq":[function(require,module,exports) {
// Import the functions you need from the SDKs you need
var _firebaseApp = require("/scripts/firebaseApp");
var _firebaseDatabase = require("/scripts/firebaseDatabase");
// Your web app's Firebase configuration
const firebaseConfig = {
    apiKey: "AIzaSyCmUypwrZbEQFi50k51k6pActdXqE32cNk",
    authDomain: "test1-70969.firebaseapp.com",
    projectId: "test1-70969",
    storageBucket: "test1-70969.appspot.com",
    messagingSenderId: "946281572913",
    appId: "1:946281572913:web:2f4e7f24c04f6618800310",
    databaseURL: "https://test1-70969-default-rtdb.asia-southeast1.firebasedatabase.app"
};
// Initialize Firebase
const app = (0, _firebaseApp.initializeApp)(firebaseConfig);
const dB = (0, _firebaseDatabase.getDatabase)();
// REFERENCES
const nameBox = document.getElementById("username-input");
const ageBox = document.getElementById("age-input");
const submitBtn = document.getElementById("start-button");
function save(event1) {
    event1.preventDefault(); // prevent form submission from reloading the page
    (0, _firebaseDatabase.set)((0, _firebaseDatabase.ref)(dB, "PlayerName/" + nameBox.value), {
        UserName: nameBox.value,
        Age: ageBox.value
    }).then(()=>{
        // alert("Data Stored Successfully!");
        console.log("Successful");
        window.location.href = "/KeyFinger.html";
    }).catch((error)=>{
        // alert("Operation not Successful!, ERROR" + error);
        console.log("Unsuccessful");
    });
}
submitBtn.addEventListener("click", ()=>{
    if (nameBox.value === "" || ageBox.value === "") alert("Please enter Username and Age to start the Game :)");
    else save(event);
});

},{"/scripts/firebaseApp":"fvEBi","/scripts/firebaseDatabase":"1OqIh"}],"fvEBi":[function(require,module,exports) {
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FirebaseError", ()=>FirebaseError) //# sourceMappingURL=firebase-app.js.map
;
parcelHelpers.export(exports, "SDK_VERSION", ()=>SDK_VERSION);
parcelHelpers.export(exports, "_DEFAULT_ENTRY_NAME", ()=>DEFAULT_ENTRY_NAME);
parcelHelpers.export(exports, "_addComponent", ()=>_addComponent);
parcelHelpers.export(exports, "_addOrOverwriteComponent", ()=>_addOrOverwriteComponent);
parcelHelpers.export(exports, "_apps", ()=>_apps);
parcelHelpers.export(exports, "_clearComponents", ()=>_clearComponents);
parcelHelpers.export(exports, "_components", ()=>_components);
parcelHelpers.export(exports, "_getProvider", ()=>_getProvider);
parcelHelpers.export(exports, "_registerComponent", ()=>_registerComponent);
parcelHelpers.export(exports, "_removeServiceInstance", ()=>_removeServiceInstance);
parcelHelpers.export(exports, "deleteApp", ()=>deleteApp);
parcelHelpers.export(exports, "getApp", ()=>getApp);
parcelHelpers.export(exports, "getApps", ()=>getApps);
parcelHelpers.export(exports, "initializeApp", ()=>initializeApp);
parcelHelpers.export(exports, "onLog", ()=>onLog);
parcelHelpers.export(exports, "registerVersion", ()=>registerVersion);
parcelHelpers.export(exports, "setLogLevel", ()=>setLogLevel);
var process = require("3279d65c761d355");
var global = arguments[3];
const stringToByteArray$1 = function(str) {
    // TODO(user): Use native implementations if/when available
    const out = [];
    let p = 0;
    for(let i = 0; i < str.length; i++){
        let c = str.charCodeAt(i);
        if (c < 128) out[p++] = c;
        else if (c < 2048) {
            out[p++] = c >> 6 | 192;
            out[p++] = c & 63 | 128;
        } else if ((c & 0xfc00) === 0xd800 && i + 1 < str.length && (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
            // Surrogate Pair
            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);
            out[p++] = c >> 18 | 240;
            out[p++] = c >> 12 & 63 | 128;
            out[p++] = c >> 6 & 63 | 128;
            out[p++] = c & 63 | 128;
        } else {
            out[p++] = c >> 12 | 224;
            out[p++] = c >> 6 & 63 | 128;
            out[p++] = c & 63 | 128;
        }
    }
    return out;
};
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param bytes Array of numbers representing characters.
 * @return Stringification of the array.
 */ const byteArrayToString = function(bytes) {
    // TODO(user): Use native implementations if/when available
    const out = [];
    let pos = 0, c = 0;
    while(pos < bytes.length){
        const c1 = bytes[pos++];
        if (c1 < 128) out[c++] = String.fromCharCode(c1);
        else if (c1 > 191 && c1 < 224) {
            const c2 = bytes[pos++];
            out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
        } else if (c1 > 239 && c1 < 365) {
            // Surrogate Pair
            const c2 = bytes[pos++];
            const c3 = bytes[pos++];
            const c4 = bytes[pos++];
            const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;
            out[c++] = String.fromCharCode(0xd800 + (u >> 10));
            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));
        } else {
            const c2 = bytes[pos++];
            const c3 = bytes[pos++];
            out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        }
    }
    return out.join("");
};
// We define it as an object literal instead of a class because a class compiled down to es5 can't
// be treeshaked. https://github.com/rollup/rollup/issues/1691
// Static lookup maps, lazily populated by init_()
const base64 = {
    /**
     * Maps bytes to characters.
     */ byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     */ charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @private
     */ byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @private
     */ charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     */ ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     */ get ENCODED_VALS () {
        return this.ENCODED_VALS_BASE + "+/=";
    },
    /**
     * Our websafe alphabet.
     */ get ENCODED_VALS_WEBSAFE () {
        return this.ENCODED_VALS_BASE + "-_.";
    },
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     */ HAS_NATIVE_SUPPORT: typeof atob === "function",
    /**
     * Base64-encode an array of bytes.
     *
     * @param input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */ encodeByteArray (input, webSafe) {
        if (!Array.isArray(input)) throw Error("encodeByteArray takes an array as a parameter");
        this.init_();
        const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
        const output = [];
        for(let i = 0; i < input.length; i += 3){
            const byte1 = input[i];
            const haveByte2 = i + 1 < input.length;
            const byte2 = haveByte2 ? input[i + 1] : 0;
            const haveByte3 = i + 2 < input.length;
            const byte3 = haveByte3 ? input[i + 2] : 0;
            const outByte1 = byte1 >> 2;
            const outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;
            let outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;
            let outByte4 = byte3 & 0x3f;
            if (!haveByte3) {
                outByte4 = 64;
                if (!haveByte2) outByte3 = 64;
            }
            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join("");
    },
    /**
     * Base64-encode a string.
     *
     * @param input A string to encode.
     * @param webSafe If true, we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */ encodeString (input, webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !webSafe) return btoa(input);
        return this.encodeByteArray(stringToByteArray$1(input), webSafe);
    },
    /**
     * Base64-decode a string.
     *
     * @param input to decode.
     * @param webSafe True if we should use the
     *     alternative alphabet.
     * @return string representing the decoded value.
     */ decodeString (input, webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !webSafe) return atob(input);
        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
    },
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param input Input to decode.
     * @param webSafe True if we should use the web-safe alphabet.
     * @return bytes representing the decoded value.
     */ decodeStringToByteArray (input, webSafe) {
        this.init_();
        const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
        const output = [];
        for(let i = 0; i < input.length;){
            const byte1 = charToByteMap[input.charAt(i++)];
            const haveByte2 = i < input.length;
            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
            ++i;
            const haveByte3 = i < input.length;
            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            const haveByte4 = i < input.length;
            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) throw new DecodeBase64StringError();
            const outByte1 = byte1 << 2 | byte2 >> 4;
            output.push(outByte1);
            if (byte3 !== 64) {
                const outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;
                output.push(outByte2);
                if (byte4 !== 64) {
                    const outByte3 = byte3 << 6 & 0xc0 | byte4;
                    output.push(outByte3);
                }
            }
        }
        return output;
    },
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */ init_ () {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {};
            this.charToByteMap_ = {};
            this.byteToCharMapWebSafe_ = {};
            this.charToByteMapWebSafe_ = {};
            // We want quick mappings back and forth, so we precompute two maps.
            for(let i = 0; i < this.ENCODED_VALS.length; i++){
                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
                this.charToByteMap_[this.byteToCharMap_[i]] = i;
                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
                // Be forgiving when decoding and correctly decode both encodings.
                if (i >= this.ENCODED_VALS_BASE.length) {
                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
                }
            }
        }
    }
};
/**
 * An error encountered while decoding base64 string.
 */ class DecodeBase64StringError extends Error {
    constructor(){
        super(...arguments);
        this.name = "DecodeBase64StringError";
    }
}
/**
 * URL-safe base64 encoding
 */ const base64Encode = function(str) {
    const utf8Bytes = stringToByteArray$1(str);
    return base64.encodeByteArray(utf8Bytes, true);
};
/**
 * URL-safe base64 encoding (without "." padding in the end).
 * e.g. Used in JSON Web Token (JWT) parts.
 */ const base64urlEncodeWithoutPadding = function(str) {
    // Use base64url encoding and remove padding in the end (dot characters).
    return base64Encode(str).replace(/\./g, "");
};
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param str To be decoded
 * @return Decoded result, if possible
 */ const base64Decode = function(str) {
    try {
        return base64.decodeString(str, true);
    } catch (e) {
        console.error("base64Decode failed: ", e);
    }
    return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Polyfill for `globalThis` object.
 * @returns the `globalThis` object for the given environment.
 * @public
 */ function getGlobal() {
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const getDefaultsFromGlobal = ()=>getGlobal().__FIREBASE_DEFAULTS__;
/**
 * Attempt to read defaults from a JSON string provided to
 * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in
 * process(.)env(.)__FIREBASE_DEFAULTS_PATH__
 * The dots are in parens because certain compilers (Vite?) cannot
 * handle seeing that variable in comments.
 * See https://github.com/firebase/firebase-js-sdk/issues/6838
 */ const getDefaultsFromEnvVariable = ()=>{
    if (typeof process === "undefined" || typeof process.env === "undefined") return;
    const defaultsJsonString = undefined;
    if (defaultsJsonString) return JSON.parse(defaultsJsonString);
};
const getDefaultsFromCookie = ()=>{
    if (typeof document === "undefined") return;
    let match;
    try {
        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
    } catch (e) {
        // Some environments such as Angular Universal SSR have a
        // `document` object but error on accessing `document.cookie`.
        return;
    }
    const decoded = match && base64Decode(match[1]);
    return decoded && JSON.parse(decoded);
};
/**
 * Get the __FIREBASE_DEFAULTS__ object. It checks in order:
 * (1) if such an object exists as a property of `globalThis`
 * (2) if such an object was provided on a shell environment variable
 * (3) if such an object exists in a cookie
 * @public
 */ const getDefaults = ()=>{
    try {
        return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();
    } catch (e) {
        /**
         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due
         * to any environment case we have not accounted for. Log to
         * info instead of swallowing so we can find these unknown cases
         * and add paths for them if needed.
         */ console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
        return;
    }
};
/**
 * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.
 * @public
 */ const getDefaultAppConfig = ()=>{
    var _a;
    return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Deferred {
    constructor(){
        this.reject = ()=>{};
        this.resolve = ()=>{};
        this.promise = new Promise((resolve, reject)=>{
            this.resolve = resolve;
            this.reject = reject;
        });
    }
    /**
     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
     * and returns a node-style callback which will resolve or reject the Deferred's promise.
     */ wrapCallback(callback) {
        return (error, value)=>{
            if (error) this.reject(error);
            else this.resolve(value);
            if (typeof callback === "function") {
                // Attaching noop handler just in case developer wasn't expecting
                // promises
                this.promise.catch(()=>{});
                // Some of our callbacks don't expect a value and our own tests
                // assert that the parameter length is 1
                if (callback.length === 1) callback(error);
                else callback(error, value);
            }
        };
    }
}
/**
 * This method checks if indexedDB is supported by current browser/service worker context
 * @return true if indexedDB is supported by current browser/service worker context
 */ function isIndexedDBAvailable() {
    try {
        return typeof indexedDB === "object";
    } catch (e) {
        return false;
    }
}
/**
 * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject
 * if errors occur during the database open operation.
 *
 * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox
 * private browsing)
 */ function validateIndexedDBOpenable() {
    return new Promise((resolve, reject)=>{
        try {
            let preExist = true;
            const DB_CHECK_NAME = "validate-browser-context-for-indexeddb-analytics-module";
            const request = self.indexedDB.open(DB_CHECK_NAME);
            request.onsuccess = ()=>{
                request.result.close();
                // delete database only when it doesn't pre-exist
                if (!preExist) self.indexedDB.deleteDatabase(DB_CHECK_NAME);
                resolve(true);
            };
            request.onupgradeneeded = ()=>{
                preExist = false;
            };
            request.onerror = ()=>{
                var _a;
                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || "");
            };
        } catch (error) {
            reject(error);
        }
    });
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @fileoverview Standardized Firebase Error.
 *
 * Usage:
 *
 *   // Typescript string literals for type-safe codes
 *   type Err =
 *     'unknown' |
 *     'object-not-found'
 *     ;
 *
 *   // Closure enum for type-safe error codes
 *   // at-enum {string}
 *   var Err = {
 *     UNKNOWN: 'unknown',
 *     OBJECT_NOT_FOUND: 'object-not-found',
 *   }
 *
 *   let errors: Map<Err, string> = {
 *     'generic-error': "Unknown error",
 *     'file-not-found': "Could not find file: {$file}",
 *   };
 *
 *   // Type-safe function - must pass a valid error code as param.
 *   let error = new ErrorFactory<Err>('service', 'Service', errors);
 *
 *   ...
 *   throw error.create(Err.GENERIC);
 *   ...
 *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});
 *   ...
 *   // Service: Could not file file: foo.txt (service/file-not-found).
 *
 *   catch (e) {
 *     assert(e.message === "Could not find file: foo.txt.");
 *     if ((e as FirebaseError)?.code === 'service/file-not-found') {
 *       console.log("Could not read file: " + e['file']);
 *     }
 *   }
 */ const ERROR_NAME = "FirebaseError";
// Based on code from:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types
class FirebaseError extends Error {
    constructor(/** The error code for this error. */ code, message, /** Custom data for this error. */ customData){
        super(message);
        this.code = code;
        this.customData = customData;
        /** The custom name for all FirebaseErrors. */ this.name = ERROR_NAME;
        // Fix For ES5
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, FirebaseError.prototype);
        // Maintains proper stack trace for where our error was thrown.
        // Only available on V8.
        if (Error.captureStackTrace) Error.captureStackTrace(this, ErrorFactory.prototype.create);
    }
}
class ErrorFactory {
    constructor(service, serviceName, errors){
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
    }
    create(code, ...data) {
        const customData = data[0] || {};
        const fullCode = `${this.service}/${code}`;
        const template = this.errors[code];
        const message = template ? replaceTemplate(template, customData) : "Error";
        // Service Name: Error message (service/code).
        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
        const error = new FirebaseError(fullCode, fullMessage, customData);
        return error;
    }
}
function replaceTemplate(template, data) {
    return template.replace(PATTERN, (_, key)=>{
        const value = data[key];
        return value != null ? String(value) : `<${key}?>`;
    });
}
const PATTERN = /\{\$([^}]+)}/g;
/**
 * Deep equal two objects. Support Arrays and Objects.
 */ function deepEqual(a, b) {
    if (a === b) return true;
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    for (const k of aKeys){
        if (!bKeys.includes(k)) return false;
        const aProp = a[k];
        const bProp = b[k];
        if (isObject(aProp) && isObject(bProp)) {
            if (!deepEqual(aProp, bProp)) return false;
        } else if (aProp !== bProp) return false;
    }
    for (const k of bKeys){
        if (!aKeys.includes(k)) return false;
    }
    return true;
}
function isObject(thing) {
    return thing !== null && typeof thing === "object";
}
/**
 * Component for service name T, e.g. `auth`, `auth-internal`
 */ class Component {
    /**
     *
     * @param name The public service name, e.g. app, auth, firestore, database
     * @param instanceFactory Service factory responsible for creating the public interface
     * @param type whether the service provided by the component is public or private
     */ constructor(name, instanceFactory, type){
        this.name = name;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        /**
         * Properties to be added to the service namespace
         */ this.serviceProps = {};
        this.instantiationMode = "LAZY" /* InstantiationMode.LAZY */ ;
        this.onInstanceCreated = null;
    }
    setInstantiationMode(mode) {
        this.instantiationMode = mode;
        return this;
    }
    setMultipleInstances(multipleInstances) {
        this.multipleInstances = multipleInstances;
        return this;
    }
    setServiceProps(props) {
        this.serviceProps = props;
        return this;
    }
    setInstanceCreatedCallback(callback) {
        this.onInstanceCreated = callback;
        return this;
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const DEFAULT_ENTRY_NAME$1 = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Provider for instance for service name T, e.g. 'auth', 'auth-internal'
 * NameServiceMapping[T] is an alias for the type of the instance
 */ class Provider {
    constructor(name, container){
        this.name = name;
        this.container = container;
        this.component = null;
        this.instances = new Map();
        this.instancesDeferred = new Map();
        this.instancesOptions = new Map();
        this.onInitCallbacks = new Map();
    }
    /**
     * @param identifier A provider can provide mulitple instances of a service
     * if this.component.multipleInstances is true.
     */ get(identifier) {
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) {
            const deferred = new Deferred();
            this.instancesDeferred.set(normalizedIdentifier, deferred);
            if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) // initialize the service if it can be auto-initialized
            try {
                const instance = this.getOrInitializeService({
                    instanceIdentifier: normalizedIdentifier
                });
                if (instance) deferred.resolve(instance);
            } catch (e) {
            // when the instance factory throws an exception during get(), it should not cause
            // a fatal error. We just return the unresolved promise in this case.
            }
        }
        return this.instancesDeferred.get(normalizedIdentifier).promise;
    }
    getImmediate(options) {
        var _a;
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) try {
            return this.getOrInitializeService({
                instanceIdentifier: normalizedIdentifier
            });
        } catch (e) {
            if (optional) return null;
            else throw e;
        }
        else {
            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw
            if (optional) return null;
            else throw Error(`Service ${this.name} is not available`);
        }
    }
    getComponent() {
        return this.component;
    }
    setComponent(component) {
        if (component.name !== this.name) throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
        if (this.component) throw Error(`Component for ${this.name} has already been provided`);
        this.component = component;
        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)
        if (!this.shouldAutoInitialize()) return;
        // if the service is eager, initialize the default instance
        if (isComponentEager(component)) try {
            this.getOrInitializeService({
                instanceIdentifier: DEFAULT_ENTRY_NAME$1
            });
        } catch (e) {
        // when the instance factory for an eager Component throws an exception during the eager
        // initialization, it should not cause a fatal error.
        // TODO: Investigate if we need to make it configurable, because some component may want to cause
        // a fatal error in this case?
        }
        // Create service instances for the pending promises and resolve them
        // NOTE: if this.multipleInstances is false, only the default instance will be created
        // and all promises with resolve with it regardless of the identifier.
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()){
            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            try {
                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.
                const instance = this.getOrInitializeService({
                    instanceIdentifier: normalizedIdentifier
                });
                instanceDeferred.resolve(instance);
            } catch (e) {
            // when the instance factory throws an exception, it should not cause
            // a fatal error. We just leave the promise unresolved.
            }
        }
    }
    clearInstance(identifier = DEFAULT_ENTRY_NAME$1) {
        this.instancesDeferred.delete(identifier);
        this.instancesOptions.delete(identifier);
        this.instances.delete(identifier);
    }
    // app.delete() will call this method on every provider to delete the services
    // TODO: should we mark the provider as deleted?
    async delete() {
        const services = Array.from(this.instances.values());
        await Promise.all([
            ...services.filter((service)=>"INTERNAL" in service) // legacy services
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .map((service)=>service.INTERNAL.delete()),
            ...services.filter((service)=>"_delete" in service) // modularized services
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .map((service)=>service._delete())
        ]);
    }
    isComponentSet() {
        return this.component != null;
    }
    isInitialized(identifier = DEFAULT_ENTRY_NAME$1) {
        return this.instances.has(identifier);
    }
    getOptions(identifier = DEFAULT_ENTRY_NAME$1) {
        return this.instancesOptions.get(identifier) || {};
    }
    initialize(opts = {}) {
        const { options ={}  } = opts;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
        if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`);
        const instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier,
            options
        });
        // resolve any pending promise waiting for the service instance
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()){
            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            if (normalizedIdentifier === normalizedDeferredIdentifier) instanceDeferred.resolve(instance);
        }
        return instance;
    }
    /**
     *
     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
     *
     * @param identifier An optional instance identifier
     * @returns a function to unregister the callback
     */ onInit(callback, identifier) {
        var _a;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        const existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) callback(existingInstance, normalizedIdentifier);
        return ()=>{
            existingCallbacks.delete(callback);
        };
    }
    /**
     * Invoke onInit callbacks synchronously
     * @param instance the service instance`
     */ invokeOnInitCallbacks(instance, identifier) {
        const callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) return;
        for (const callback of callbacks)try {
            callback(instance, identifier);
        } catch (_a) {
        // ignore errors in the onInit callback
        }
    }
    getOrInitializeService({ instanceIdentifier , options ={}  }) {
        let instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) {
            instance = this.component.instanceFactory(this.container, {
                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
                options
            });
            this.instances.set(instanceIdentifier, instance);
            this.instancesOptions.set(instanceIdentifier, options);
            /**
             * Invoke onInit listeners.
             * Note this.component.onInstanceCreated is different, which is used by the component creator,
             * while onInit listeners are registered by consumers of the provider.
             */ this.invokeOnInitCallbacks(instance, instanceIdentifier);
            /**
             * Order is important
             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which
             * makes `isInitialized()` return true.
             */ if (this.component.onInstanceCreated) try {
                this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
            } catch (_a) {
            // ignore errors in the onInstanceCreatedCallback
            }
        }
        return instance || null;
    }
    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME$1) {
        if (this.component) return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME$1;
        else return identifier; // assume multiple instances are supported before the component is provided.
    }
    shouldAutoInitialize() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT" /* InstantiationMode.EXPLICIT */ ;
    }
}
// undefined should be passed to the service factory for the default instance
function normalizeIdentifierForFactory(identifier) {
    return identifier === DEFAULT_ENTRY_NAME$1 ? undefined : identifier;
}
function isComponentEager(component) {
    return component.instantiationMode === "EAGER" /* InstantiationMode.EAGER */ ;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`
 */ class ComponentContainer {
    constructor(name){
        this.name = name;
        this.providers = new Map();
    }
    /**
     *
     * @param component Component being added
     * @param overwrite When a component with the same name has already been registered,
     * if overwrite is true: overwrite the existing component with the new component and create a new
     * provider with the new component. It can be useful in tests where you want to use different mocks
     * for different tests.
     * if overwrite is false: throw an exception
     */ addComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
        provider.setComponent(component);
    }
    addOrOverwriteComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) // delete the existing provider from the container, so we can register the new component
        this.providers.delete(component.name);
        this.addComponent(component);
    }
    /**
     * getProvider provides a type safe interface where it can only be called with a field name
     * present in NameServiceMapping interface.
     *
     * Firebase SDKs providing services should extend NameServiceMapping interface to register
     * themselves.
     */ getProvider(name) {
        if (this.providers.has(name)) return this.providers.get(name);
        // create a Provider for a service that hasn't registered with Firebase
        const provider = new Provider(name, this);
        this.providers.set(name, provider);
        return provider;
    }
    getProviders() {
        return Array.from(this.providers.values());
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * A container for all of the Logger instances
 */ const instances = [];
/**
 * The JS SDK supports 5 log levels and also allows a user the ability to
 * silence the logs altogether.
 *
 * The order is a follows:
 * DEBUG < VERBOSE < INFO < WARN < ERROR
 *
 * All of the log types above the current log level will be captured (i.e. if
 * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and
 * `VERBOSE` logs will not)
 */ var LogLevel;
(function(LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
const levelStringToEnum = {
    "debug": LogLevel.DEBUG,
    "verbose": LogLevel.VERBOSE,
    "info": LogLevel.INFO,
    "warn": LogLevel.WARN,
    "error": LogLevel.ERROR,
    "silent": LogLevel.SILENT
};
/**
 * The default log level
 */ const defaultLogLevel = LogLevel.INFO;
/**
 * By default, `console.debug` is not displayed in the developer console (in
 * chrome). To avoid forcing users to have to opt-in to these logs twice
 * (i.e. once for firebase, and once in the console), we are sending `DEBUG`
 * logs to the `console.log` function.
 */ const ConsoleMethod = {
    [LogLevel.DEBUG]: "log",
    [LogLevel.VERBOSE]: "log",
    [LogLevel.INFO]: "info",
    [LogLevel.WARN]: "warn",
    [LogLevel.ERROR]: "error"
};
/**
 * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR
 * messages on to their corresponding console counterparts (if the log method
 * is supported by the current log level)
 */ const defaultLogHandler = (instance, logType, ...args)=>{
    if (logType < instance.logLevel) return;
    const now = new Date().toISOString();
    const method = ConsoleMethod[logType];
    if (method) console[method](`[${now}]  ${instance.name}:`, ...args);
    else throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
};
class Logger {
    /**
     * Gives you an instance of a Logger to capture messages according to
     * Firebase's logging scheme.
     *
     * @param name The name that the logs will be associated with
     */ constructor(name){
        this.name = name;
        /**
         * The log level of the given Logger instance.
         */ this._logLevel = defaultLogLevel;
        /**
         * The main (internal) log handler for the Logger instance.
         * Can be set to a new function in internal package code but not by user.
         */ this._logHandler = defaultLogHandler;
        /**
         * The optional, additional, user-defined log handler for the Logger instance.
         */ this._userLogHandler = null;
        /**
         * Capture the current instance for later use
         */ instances.push(this);
    }
    get logLevel() {
        return this._logLevel;
    }
    set logLevel(val) {
        if (!(val in LogLevel)) throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
        this._logLevel = val;
    }
    // Workaround for setter/getter having to be the same type.
    setLogLevel(val) {
        this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
    }
    get logHandler() {
        return this._logHandler;
    }
    set logHandler(val) {
        if (typeof val !== "function") throw new TypeError("Value assigned to `logHandler` must be a function");
        this._logHandler = val;
    }
    get userLogHandler() {
        return this._userLogHandler;
    }
    set userLogHandler(val) {
        this._userLogHandler = val;
    }
    /**
     * The functions below are all based on the `console` interface
     */ debug(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
        this._logHandler(this, LogLevel.DEBUG, ...args);
    }
    log(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);
        this._logHandler(this, LogLevel.VERBOSE, ...args);
    }
    info(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
        this._logHandler(this, LogLevel.INFO, ...args);
    }
    warn(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
        this._logHandler(this, LogLevel.WARN, ...args);
    }
    error(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
        this._logHandler(this, LogLevel.ERROR, ...args);
    }
}
function setLogLevel$1(level) {
    instances.forEach((inst)=>{
        inst.setLogLevel(level);
    });
}
function setUserLogHandler(logCallback, options) {
    for (const instance of instances){
        let customLogLevel = null;
        if (options && options.level) customLogLevel = levelStringToEnum[options.level];
        if (logCallback === null) instance.userLogHandler = null;
        else instance.userLogHandler = (instance, level, ...args)=>{
            const message = args.map((arg)=>{
                if (arg == null) return null;
                else if (typeof arg === "string") return arg;
                else if (typeof arg === "number" || typeof arg === "boolean") return arg.toString();
                else if (arg instanceof Error) return arg.message;
                else try {
                    return JSON.stringify(arg);
                } catch (ignored) {
                    return null;
                }
            }).filter((arg)=>arg).join(" ");
            if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) logCallback({
                level: LogLevel[level].toLowerCase(),
                message,
                args,
                type: instance.name
            });
        };
    }
}
const instanceOfAny = (object, constructors)=>constructors.some((c)=>object instanceof c);
let idbProxyableTypes;
let cursorAdvanceMethods;
// This is a function to prevent it throwing up in node environments.
function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [
        IDBDatabase,
        IDBObjectStore,
        IDBIndex,
        IDBCursor,
        IDBTransaction
    ]);
}
// This is a function to prevent it throwing up in node environments.
function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [
        IDBCursor.prototype.advance,
        IDBCursor.prototype.continue,
        IDBCursor.prototype.continuePrimaryKey
    ]);
}
const cursorRequestMap = new WeakMap();
const transactionDoneMap = new WeakMap();
const transactionStoreNamesMap = new WeakMap();
const transformCache = new WeakMap();
const reverseTransformCache = new WeakMap();
function promisifyRequest(request) {
    const promise = new Promise((resolve, reject)=>{
        const unlisten = ()=>{
            request.removeEventListener("success", success);
            request.removeEventListener("error", error);
        };
        const success = ()=>{
            resolve(wrap(request.result));
            unlisten();
        };
        const error = ()=>{
            reject(request.error);
            unlisten();
        };
        request.addEventListener("success", success);
        request.addEventListener("error", error);
    });
    promise.then((value)=>{
        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
        // (see wrapFunction).
        if (value instanceof IDBCursor) cursorRequestMap.set(value, request);
    // Catching to avoid "Uncaught Promise exceptions"
    }).catch(()=>{});
    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
    // is because we create many promises from a single IDBRequest.
    reverseTransformCache.set(promise, request);
    return promise;
}
function cacheDonePromiseForTransaction(tx) {
    // Early bail if we've already created a done promise for this transaction.
    if (transactionDoneMap.has(tx)) return;
    const done = new Promise((resolve, reject)=>{
        const unlisten = ()=>{
            tx.removeEventListener("complete", complete);
            tx.removeEventListener("error", error);
            tx.removeEventListener("abort", error);
        };
        const complete = ()=>{
            resolve();
            unlisten();
        };
        const error = ()=>{
            reject(tx.error || new DOMException("AbortError", "AbortError"));
            unlisten();
        };
        tx.addEventListener("complete", complete);
        tx.addEventListener("error", error);
        tx.addEventListener("abort", error);
    });
    // Cache it for later retrieval.
    transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
    get (target, prop, receiver) {
        if (target instanceof IDBTransaction) {
            // Special handling for transaction.done.
            if (prop === "done") return transactionDoneMap.get(target);
            // Polyfill for objectStoreNames because of Edge.
            if (prop === "objectStoreNames") return target.objectStoreNames || transactionStoreNamesMap.get(target);
            // Make tx.store return the only store in the transaction, or undefined if there are many.
            if (prop === "store") return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);
        }
        // Else transform whatever we get back.
        return wrap(target[prop]);
    },
    set (target, prop, value) {
        target[prop] = value;
        return true;
    },
    has (target, prop) {
        if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) return true;
        return prop in target;
    }
};
function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
    // Due to expected object equality (which is enforced by the caching in `wrap`), we
    // only create one new func per func.
    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
    if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) return function(storeNames, ...args) {
        const tx = func.call(unwrap(this), storeNames, ...args);
        transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [
            storeNames
        ]);
        return wrap(tx);
    };
    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
    // with real promises, so each advance methods returns a new promise for the cursor object, or
    // undefined if the end of the cursor has been reached.
    if (getCursorAdvanceMethods().includes(func)) return function(...args) {
        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
        // the original object.
        func.apply(unwrap(this), args);
        return wrap(cursorRequestMap.get(this));
    };
    return function(...args) {
        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
        // the original object.
        return wrap(func.apply(unwrap(this), args));
    };
}
function transformCachableValue(value) {
    if (typeof value === "function") return wrapFunction(value);
    // This doesn't return, it just creates a 'done' promise for the transaction,
    // which is later returned for transaction.done (see idbObjectHandler).
    if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);
    // Return the same value back if we're not going to transform it.
    return value;
}
function wrap(value) {
    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
    if (value instanceof IDBRequest) return promisifyRequest(value);
    // If we've already transformed this value before, reuse the transformed value.
    // This is faster, but it also provides object equality.
    if (transformCache.has(value)) return transformCache.get(value);
    const newValue = transformCachableValue(value);
    // Not all types are transformed.
    // These may be primitive types, so they can't be WeakMap keys.
    if (newValue !== value) {
        transformCache.set(value, newValue);
        reverseTransformCache.set(newValue, value);
    }
    return newValue;
}
const unwrap = (value)=>reverseTransformCache.get(value);
/**
 * Open a database.
 *
 * @param name Name of the database.
 * @param version Schema version.
 * @param callbacks Additional callbacks.
 */ function openDB(name, version, { blocked , upgrade , blocking , terminated  } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap(request);
    if (upgrade) request.addEventListener("upgradeneeded", (event)=>{
        upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));
    });
    if (blocked) request.addEventListener("blocked", ()=>blocked());
    openPromise.then((db)=>{
        if (terminated) db.addEventListener("close", ()=>terminated());
        if (blocking) db.addEventListener("versionchange", ()=>blocking());
    }).catch(()=>{});
    return openPromise;
}
const readMethods = [
    "get",
    "getKey",
    "getAll",
    "getAllKeys",
    "count"
];
const writeMethods = [
    "put",
    "add",
    "delete",
    "clear"
];
const cachedMethods = new Map();
function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) return;
    if (cachedMethods.get(prop)) return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, "");
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (// Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) return;
    const method = async function(storeName, ...args) {
        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
        const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
        let target = tx.store;
        if (useIndex) target = target.index(args.shift());
        // Must reject if op rejects.
        // If it's a write operation, must reject if tx.done rejects.
        // Must reject with op rejection first.
        // Must resolve with op value.
        // Must handle both promises (no unhandled rejections)
        return (await Promise.all([
            target[targetFuncName](...args),
            isWrite && tx.done
        ]))[0];
    };
    cachedMethods.set(prop, method);
    return method;
}
replaceTraps((oldTraps)=>({
        ...oldTraps,
        get: (target, prop, receiver)=>getMethod(target, prop) || oldTraps.get(target, prop, receiver),
        has: (target, prop)=>!!getMethod(target, prop) || oldTraps.has(target, prop)
    }));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class PlatformLoggerServiceImpl {
    constructor(container){
        this.container = container;
    }
    // In initial implementation, this will be called by installations on
    // auth token refresh, and installations will send this string.
    getPlatformInfoString() {
        const providers = this.container.getProviders();
        // Loop through providers and get library/version pairs from any that are
        // version components.
        return providers.map((provider)=>{
            if (isVersionServiceProvider(provider)) {
                const service = provider.getImmediate();
                return `${service.library}/${service.version}`;
            } else return null;
        }).filter((logString)=>logString).join(" ");
    }
}
/**
 *
 * @param provider check if this provider provides a VersionService
 *
 * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider
 * provides VersionService. The provider is not necessarily a 'app-version'
 * provider.
 */ function isVersionServiceProvider(provider) {
    const component = provider.getComponent();
    return (component === null || component === void 0 ? void 0 : component.type) === "VERSION" /* ComponentType.VERSION */ ;
}
const name$o = "https://www.gstatic.com/firebasejs/9.20.0/firebase-app.js";
const version$1 = "0.9.8";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const logger = new Logger("https://www.gstatic.com/firebasejs/9.20.0/firebase-app.js");
const name$n = "@firebase/app-compat";
const name$m = "@firebase/analytics-compat";
const name$l = "@firebase/analytics";
const name$k = "@firebase/app-check-compat";
const name$j = "@firebase/app-check";
const name$i = "@firebase/auth";
const name$h = "@firebase/auth-compat";
const name$g = "@firebase/database";
const name$f = "@firebase/database-compat";
const name$e = "@firebase/functions";
const name$d = "@firebase/functions-compat";
const name$c = "@firebase/installations";
const name$b = "@firebase/installations-compat";
const name$a = "@firebase/messaging";
const name$9 = "@firebase/messaging-compat";
const name$8 = "@firebase/performance";
const name$7 = "@firebase/performance-compat";
const name$6 = "@firebase/remote-config";
const name$5 = "@firebase/remote-config-compat";
const name$4 = "@firebase/storage";
const name$3 = "@firebase/storage-compat";
const name$2 = "@firebase/firestore";
const name$1 = "@firebase/firestore-compat";
const name$p = "firebase";
const version$2 = "9.20.0";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * The default app name
 *
 * @internal
 */ const DEFAULT_ENTRY_NAME = "[DEFAULT]";
const PLATFORM_LOG_STRING = {
    [name$o]: "fire-core",
    [name$n]: "fire-core-compat",
    [name$l]: "fire-analytics",
    [name$m]: "fire-analytics-compat",
    [name$j]: "fire-app-check",
    [name$k]: "fire-app-check-compat",
    [name$i]: "fire-auth",
    [name$h]: "fire-auth-compat",
    [name$g]: "fire-rtdb",
    [name$f]: "fire-rtdb-compat",
    [name$e]: "fire-fn",
    [name$d]: "fire-fn-compat",
    [name$c]: "fire-iid",
    [name$b]: "fire-iid-compat",
    [name$a]: "fire-fcm",
    [name$9]: "fire-fcm-compat",
    [name$8]: "fire-perf",
    [name$7]: "fire-perf-compat",
    [name$6]: "fire-rc",
    [name$5]: "fire-rc-compat",
    [name$4]: "fire-gcs",
    [name$3]: "fire-gcs-compat",
    [name$2]: "fire-fst",
    [name$1]: "fire-fst-compat",
    "fire-js": "fire-js",
    [name$p]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @internal
 */ const _apps = new Map();
/**
 * Registered components.
 *
 * @internal
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
const _components = new Map();
/**
 * @param component - the component being added to this app's container
 *
 * @internal
 */ function _addComponent(app, component) {
    try {
        app.container.addComponent(component);
    } catch (e) {
        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);
    }
}
/**
 *
 * @internal
 */ function _addOrOverwriteComponent(app, component) {
    app.container.addOrOverwriteComponent(component);
}
/**
 *
 * @param component - the component to register
 * @returns whether or not the component is registered successfully
 *
 * @internal
 */ function _registerComponent(component) {
    const componentName = component.name;
    if (_components.has(componentName)) {
        logger.debug(`There were multiple attempts to register component ${componentName}.`);
        return false;
    }
    _components.set(componentName, component);
    // add the component to existing app instances
    for (const app of _apps.values())_addComponent(app, component);
    return true;
}
/**
 *
 * @param app - FirebaseApp instance
 * @param name - service name
 *
 * @returns the provider for the service with the matching name
 *
 * @internal
 */ function _getProvider(app, name) {
    const heartbeatController = app.container.getProvider("heartbeat").getImmediate({
        optional: true
    });
    if (heartbeatController) heartbeatController.triggerHeartbeat();
    return app.container.getProvider(name);
}
/**
 *
 * @param app - FirebaseApp instance
 * @param name - service name
 * @param instanceIdentifier - service instance identifier in case the service supports multiple instances
 *
 * @internal
 */ function _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {
    _getProvider(app, name).clearInstance(instanceIdentifier);
}
/**
 * Test only
 *
 * @internal
 */ function _clearComponents() {
    _components.clear();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const ERRORS = {
    ["no-app" /* AppError.NO_APP */ ]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
    ["bad-app-name" /* AppError.BAD_APP_NAME */ ]: "Illegal App name: '{$appName}",
    ["duplicate-app" /* AppError.DUPLICATE_APP */ ]: "Firebase App named '{$appName}' already exists with different options or config",
    ["app-deleted" /* AppError.APP_DELETED */ ]: "Firebase App named '{$appName}' already deleted",
    ["no-options" /* AppError.NO_OPTIONS */ ]: "Need to provide options, when not being deployed to hosting via source.",
    ["invalid-app-argument" /* AppError.INVALID_APP_ARGUMENT */ ]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
    ["invalid-log-argument" /* AppError.INVALID_LOG_ARGUMENT */ ]: "First argument to `onLog` must be null or a function.",
    ["idb-open" /* AppError.IDB_OPEN */ ]: "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
    ["idb-get" /* AppError.IDB_GET */ ]: "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
    ["idb-set" /* AppError.IDB_WRITE */ ]: "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
    ["idb-delete" /* AppError.IDB_DELETE */ ]: "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
};
const ERROR_FACTORY = new ErrorFactory("app", "Firebase", ERRORS);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class FirebaseAppImpl {
    constructor(options, config, container){
        this._isDeleted = false;
        this._options = Object.assign({}, options);
        this._config = Object.assign({}, config);
        this._name = config.name;
        this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;
        this._container = container;
        this.container.addComponent(new Component("app", ()=>this, "PUBLIC" /* ComponentType.PUBLIC */ ));
    }
    get automaticDataCollectionEnabled() {
        this.checkDestroyed();
        return this._automaticDataCollectionEnabled;
    }
    set automaticDataCollectionEnabled(val) {
        this.checkDestroyed();
        this._automaticDataCollectionEnabled = val;
    }
    get name() {
        this.checkDestroyed();
        return this._name;
    }
    get options() {
        this.checkDestroyed();
        return this._options;
    }
    get config() {
        this.checkDestroyed();
        return this._config;
    }
    get container() {
        return this._container;
    }
    get isDeleted() {
        return this._isDeleted;
    }
    set isDeleted(val) {
        this._isDeleted = val;
    }
    /**
     * This function will throw an Error if the App has already been deleted -
     * use before performing API actions on the App.
     */ checkDestroyed() {
        if (this.isDeleted) throw ERROR_FACTORY.create("app-deleted" /* AppError.APP_DELETED */ , {
            appName: this._name
        });
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * The current SDK version.
 *
 * @public
 */ const SDK_VERSION = version$2;
function initializeApp(_options, rawConfig = {}) {
    let options = _options;
    if (typeof rawConfig !== "object") {
        const name = rawConfig;
        rawConfig = {
            name
        };
    }
    const config = Object.assign({
        name: DEFAULT_ENTRY_NAME,
        automaticDataCollectionEnabled: false
    }, rawConfig);
    const name = config.name;
    if (typeof name !== "string" || !name) throw ERROR_FACTORY.create("bad-app-name" /* AppError.BAD_APP_NAME */ , {
        appName: String(name)
    });
    options || (options = getDefaultAppConfig());
    if (!options) throw ERROR_FACTORY.create("no-options" /* AppError.NO_OPTIONS */ );
    const existingApp = _apps.get(name);
    if (existingApp) {
        // return the existing app if options and config deep equal the ones in the existing app.
        if (deepEqual(options, existingApp.options) && deepEqual(config, existingApp.config)) return existingApp;
        else throw ERROR_FACTORY.create("duplicate-app" /* AppError.DUPLICATE_APP */ , {
            appName: name
        });
    }
    const container = new ComponentContainer(name);
    for (const component of _components.values())container.addComponent(component);
    const newApp = new FirebaseAppImpl(options, config, container);
    _apps.set(name, newApp);
    return newApp;
}
/**
 * Retrieves a {@link @firebase/app#FirebaseApp} instance.
 *
 * When called with no arguments, the default app is returned. When an app name
 * is provided, the app corresponding to that name is returned.
 *
 * An exception is thrown if the app being retrieved has not yet been
 * initialized.
 *
 * @example
 * ```javascript
 * // Return the default app
 * const app = getApp();
 * ```
 *
 * @example
 * ```javascript
 * // Return a named app
 * const otherApp = getApp("otherApp");
 * ```
 *
 * @param name - Optional name of the app to return. If no name is
 *   provided, the default is `"[DEFAULT]"`.
 *
 * @returns The app corresponding to the provided app name.
 *   If no app name is provided, the default app is returned.
 *
 * @public
 */ function getApp(name = DEFAULT_ENTRY_NAME) {
    const app = _apps.get(name);
    if (!app && name === DEFAULT_ENTRY_NAME) return initializeApp();
    if (!app) throw ERROR_FACTORY.create("no-app" /* AppError.NO_APP */ , {
        appName: name
    });
    return app;
}
/**
 * A (read-only) array of all initialized apps.
 * @public
 */ function getApps() {
    return Array.from(_apps.values());
}
/**
 * Renders this app unusable and frees the resources of all associated
 * services.
 *
 * @example
 * ```javascript
 * deleteApp(app)
 *   .then(function() {
 *     console.log("App deleted successfully");
 *   })
 *   .catch(function(error) {
 *     console.log("Error deleting app:", error);
 *   });
 * ```
 *
 * @public
 */ async function deleteApp(app) {
    const name = app.name;
    if (_apps.has(name)) {
        _apps.delete(name);
        await Promise.all(app.container.getProviders().map((provider)=>provider.delete()));
        app.isDeleted = true;
    }
}
/**
 * Registers a library's name and version for platform logging purposes.
 * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)
 * @param version - Current version of that library.
 * @param variant - Bundle variant, e.g., node, rn, etc.
 *
 * @public
 */ function registerVersion(libraryKeyOrName, version, variant) {
    var _a;
    // TODO: We can use this check to whitelist strings when/if we set up
    // a good whitelist system.
    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;
    if (variant) library += `-${variant}`;
    const libraryMismatch = library.match(/\s|\//);
    const versionMismatch = version.match(/\s|\//);
    if (libraryMismatch || versionMismatch) {
        const warning = [
            `Unable to register library "${library}" with version "${version}":`
        ];
        if (libraryMismatch) warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
        if (libraryMismatch && versionMismatch) warning.push("and");
        if (versionMismatch) warning.push(`version name "${version}" contains illegal characters (whitespace or "/")`);
        logger.warn(warning.join(" "));
        return;
    }
    _registerComponent(new Component(`${library}-version`, ()=>({
            library,
            version
        }), "VERSION" /* ComponentType.VERSION */ ));
}
/**
 * Sets log handler for all Firebase SDKs.
 * @param logCallback - An optional custom log handler that executes user code whenever
 * the Firebase SDK makes a logging call.
 *
 * @public
 */ function onLog(logCallback, options) {
    if (logCallback !== null && typeof logCallback !== "function") throw ERROR_FACTORY.create("invalid-log-argument" /* AppError.INVALID_LOG_ARGUMENT */ );
    setUserLogHandler(logCallback, options);
}
/**
 * Sets log level for all Firebase SDKs.
 *
 * All of the log types above the current log level are captured (i.e. if
 * you set the log level to `info`, errors are logged, but `debug` and
 * `verbose` logs are not).
 *
 * @public
 */ function setLogLevel(logLevel) {
    setLogLevel$1(logLevel);
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const DB_NAME = "firebase-heartbeat-database";
const DB_VERSION = 1;
const STORE_NAME = "firebase-heartbeat-store";
let dbPromise = null;
function getDbPromise() {
    if (!dbPromise) dbPromise = openDB(DB_NAME, DB_VERSION, {
        upgrade: (db, oldVersion)=>{
            // We don't use 'break' in this switch statement, the fall-through
            // behavior is what we want, because if there are multiple versions between
            // the old version and the current version, we want ALL the migrations
            // that correspond to those versions to run, not only the last one.
            // eslint-disable-next-line default-case
            switch(oldVersion){
                case 0:
                    db.createObjectStore(STORE_NAME);
            }
        }
    }).catch((e)=>{
        throw ERROR_FACTORY.create("idb-open" /* AppError.IDB_OPEN */ , {
            originalErrorMessage: e.message
        });
    });
    return dbPromise;
}
async function readHeartbeatsFromIndexedDB(app) {
    try {
        const db = await getDbPromise();
        return db.transaction(STORE_NAME).objectStore(STORE_NAME).get(computeKey(app));
    } catch (e) {
        if (e instanceof FirebaseError) logger.warn(e.message);
        else {
            const idbGetError = ERROR_FACTORY.create("idb-get" /* AppError.IDB_GET */ , {
                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
            });
            logger.warn(idbGetError.message);
        }
    }
}
async function writeHeartbeatsToIndexedDB(app, heartbeatObject) {
    try {
        const db = await getDbPromise();
        const tx = db.transaction(STORE_NAME, "readwrite");
        const objectStore = tx.objectStore(STORE_NAME);
        await objectStore.put(heartbeatObject, computeKey(app));
        return tx.done;
    } catch (e) {
        if (e instanceof FirebaseError) logger.warn(e.message);
        else {
            const idbGetError = ERROR_FACTORY.create("idb-set" /* AppError.IDB_WRITE */ , {
                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
            });
            logger.warn(idbGetError.message);
        }
    }
}
function computeKey(app) {
    return `${app.name}!${app.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const MAX_HEADER_BYTES = 1024;
// 30 days
const STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 2592000000;
class HeartbeatServiceImpl {
    constructor(container){
        this.container = container;
        /**
         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate
         * the header string.
         * Stores one record per date. This will be consolidated into the standard
         * format of one record per user agent string before being sent as a header.
         * Populated from indexedDB when the controller is instantiated and should
         * be kept in sync with indexedDB.
         * Leave public for easier testing.
         */ this._heartbeatsCache = null;
        const app = this.container.getProvider("app").getImmediate();
        this._storage = new HeartbeatStorageImpl(app);
        this._heartbeatsCachePromise = this._storage.read().then((result)=>{
            this._heartbeatsCache = result;
            return result;
        });
    }
    /**
     * Called to report a heartbeat. The function will generate
     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
     * to IndexedDB.
     * Note that we only store one heartbeat per day. So if a heartbeat for today is
     * already logged, subsequent calls to this function in the same day will be ignored.
     */ async triggerHeartbeat() {
        const platformLogger = this.container.getProvider("platform-logger").getImmediate();
        // This is the "Firebase user agent" string from the platform logger
        // service, not the browser user agent.
        const agent = platformLogger.getPlatformInfoString();
        const date = getUTCDateString();
        if (this._heartbeatsCache === null) this._heartbeatsCache = await this._heartbeatsCachePromise;
        // Do not store a heartbeat if one is already stored for this day
        // or if a header has already been sent today.
        if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat)=>singleDateHeartbeat.date === date)) return;
        else // There is no entry for this date. Create one.
        this._heartbeatsCache.heartbeats.push({
            date,
            agent
        });
        // Remove entries older than 30 days.
        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat)=>{
            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();
            const now = Date.now();
            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
        });
        return this._storage.overwrite(this._heartbeatsCache);
    }
    /**
     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
     * It also clears all heartbeats from memory as well as in IndexedDB.
     *
     * NOTE: Consuming product SDKs should not send the header if this method
     * returns an empty string.
     */ async getHeartbeatsHeader() {
        if (this._heartbeatsCache === null) await this._heartbeatsCachePromise;
        // If it's still null or the array is empty, there is no data to send.
        if (this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0) return "";
        const date = getUTCDateString();
        // Extract as many heartbeats from the cache as will fit under the size limit.
        const { heartbeatsToSend , unsentEntries  } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
        const headerString = base64urlEncodeWithoutPadding(JSON.stringify({
            version: 2,
            heartbeats: heartbeatsToSend
        }));
        // Store last sent date to prevent another being logged/sent for the same day.
        this._heartbeatsCache.lastSentHeartbeatDate = date;
        if (unsentEntries.length > 0) {
            // Store any unsent entries if they exist.
            this._heartbeatsCache.heartbeats = unsentEntries;
            // This seems more likely than emptying the array (below) to lead to some odd state
            // since the cache isn't empty and this will be called again on the next request,
            // and is probably safest if we await it.
            await this._storage.overwrite(this._heartbeatsCache);
        } else {
            this._heartbeatsCache.heartbeats = [];
            this._storage.overwrite(this._heartbeatsCache);
        }
        return headerString;
    }
}
function getUTCDateString() {
    const today = new Date();
    // Returns date format 'YYYY-MM-DD'
    return today.toISOString().substring(0, 10);
}
function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
    // Heartbeats grouped by user agent in the standard format to be sent in
    // the header.
    const heartbeatsToSend = [];
    // Single date format heartbeats that are not sent.
    let unsentEntries = heartbeatsCache.slice();
    for (const singleDateHeartbeat of heartbeatsCache){
        // Look for an existing entry with the same user agent.
        const heartbeatEntry = heartbeatsToSend.find((hb)=>hb.agent === singleDateHeartbeat.agent);
        if (!heartbeatEntry) {
            // If no entry for this user agent exists, create one.
            heartbeatsToSend.push({
                agent: singleDateHeartbeat.agent,
                dates: [
                    singleDateHeartbeat.date
                ]
            });
            if (countBytes(heartbeatsToSend) > maxSize) {
                // If the header would exceed max size, remove the added heartbeat
                // entry and stop adding to the header.
                heartbeatsToSend.pop();
                break;
            }
        } else {
            heartbeatEntry.dates.push(singleDateHeartbeat.date);
            // If the header would exceed max size, remove the added date
            // and stop adding to the header.
            if (countBytes(heartbeatsToSend) > maxSize) {
                heartbeatEntry.dates.pop();
                break;
            }
        }
        // Pop unsent entry from queue. (Skipped if adding the entry exceeded
        // quota and the loop breaks early.)
        unsentEntries = unsentEntries.slice(1);
    }
    return {
        heartbeatsToSend,
        unsentEntries
    };
}
class HeartbeatStorageImpl {
    constructor(app){
        this.app = app;
        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
    }
    async runIndexedDBEnvironmentCheck() {
        if (!isIndexedDBAvailable()) return false;
        else return validateIndexedDBOpenable().then(()=>true).catch(()=>false);
    }
    /**
     * Read all heartbeats.
     */ async read() {
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) return {
            heartbeats: []
        };
        else {
            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
            return idbHeartbeatObject || {
                heartbeats: []
            };
        }
    }
    // overwrite the storage with the provided heartbeats
    async overwrite(heartbeatsObject) {
        var _a;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) return;
        else {
            const existingHeartbeatsObject = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
                heartbeats: heartbeatsObject.heartbeats
            });
        }
    }
    // add heartbeats
    async add(heartbeatsObject) {
        var _a;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) return;
        else {
            const existingHeartbeatsObject = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
                heartbeats: [
                    ...existingHeartbeatsObject.heartbeats,
                    ...heartbeatsObject.heartbeats
                ]
            });
        }
    }
}
/**
 * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped
 * in a platform logging header JSON object, stringified, and converted
 * to base 64.
 */ function countBytes(heartbeatsCache) {
    // base64 has a restricted set of characters, all of which should be 1 byte.
    return base64urlEncodeWithoutPadding(// heartbeatsCache wrapper properties
    JSON.stringify({
        version: 2,
        heartbeats: heartbeatsCache
    })).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ function registerCoreComponents(variant) {
    _registerComponent(new Component("platform-logger", (container)=>new PlatformLoggerServiceImpl(container), "PRIVATE" /* ComponentType.PRIVATE */ ));
    _registerComponent(new Component("heartbeat", (container)=>new HeartbeatServiceImpl(container), "PRIVATE" /* ComponentType.PRIVATE */ ));
    // Register `app` package.
    registerVersion(name$o, version$1, variant);
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    registerVersion(name$o, version$1, "esm2017");
    // Register platform SDK identifier (no version).
    registerVersion("fire-js", "");
}
/**
 * Firebase App
 *
 * @remarks This package coordinates the communication between the different Firebase components
 * @packageDocumentation
 */ registerCoreComponents("");
var name = "firebase";
var version = "9.20.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ registerVersion(name, version, "cdn");

},{"3279d65c761d355":"d5jf4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"1OqIh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DataSnapshot", ()=>rr) //# sourceMappingURL=firebase-database.js.map
;
parcelHelpers.export(exports, "Database", ()=>Zr);
parcelHelpers.export(exports, "OnDisconnect", ()=>Zs);
parcelHelpers.export(exports, "QueryConstraint", ()=>Sr);
parcelHelpers.export(exports, "TransactionResult", ()=>uo);
parcelHelpers.export(exports, "_QueryImpl", ()=>er);
parcelHelpers.export(exports, "_QueryParams", ()=>jt);
parcelHelpers.export(exports, "_ReferenceImpl", ()=>sr);
parcelHelpers.export(exports, "_TEST_ACCESS_forceRestClient", ()=>fo);
parcelHelpers.export(exports, "_TEST_ACCESS_hijackHash", ()=>po);
parcelHelpers.export(exports, "_repoManagerDatabaseFromApp", ()=>Xr);
parcelHelpers.export(exports, "_setSDKVersion", ()=>j);
parcelHelpers.export(exports, "_validatePathString", ()=>_s);
parcelHelpers.export(exports, "_validateWritablePath", ()=>ps);
parcelHelpers.export(exports, "child", ()=>lr);
parcelHelpers.export(exports, "connectDatabaseEmulator", ()=>so);
parcelHelpers.export(exports, "enableLogging", ()=>ao);
parcelHelpers.export(exports, "endAt", ()=>Nr);
parcelHelpers.export(exports, "endBefore", ()=>xr);
parcelHelpers.export(exports, "equalTo", ()=>Qr);
parcelHelpers.export(exports, "forceLongPolling", ()=>no);
parcelHelpers.export(exports, "forceWebSockets", ()=>to);
parcelHelpers.export(exports, "get", ()=>gr);
parcelHelpers.export(exports, "getDatabase", ()=>io);
parcelHelpers.export(exports, "goOffline", ()=>ro);
parcelHelpers.export(exports, "goOnline", ()=>oo);
parcelHelpers.export(exports, "increment", ()=>co);
parcelHelpers.export(exports, "limitToFirst", ()=>Fr);
parcelHelpers.export(exports, "limitToLast", ()=>qr);
parcelHelpers.export(exports, "off", ()=>Ir);
parcelHelpers.export(exports, "onChildAdded", ()=>wr);
parcelHelpers.export(exports, "onChildChanged", ()=>Tr);
parcelHelpers.export(exports, "onChildMoved", ()=>br);
parcelHelpers.export(exports, "onChildRemoved", ()=>Er);
parcelHelpers.export(exports, "onDisconnect", ()=>hr);
parcelHelpers.export(exports, "onValue", ()=>Cr);
parcelHelpers.export(exports, "orderByChild", ()=>Ur);
parcelHelpers.export(exports, "orderByKey", ()=>jr);
parcelHelpers.export(exports, "orderByPriority", ()=>Vr);
parcelHelpers.export(exports, "orderByValue", ()=>Yr);
parcelHelpers.export(exports, "push", ()=>cr);
parcelHelpers.export(exports, "query", ()=>$r);
parcelHelpers.export(exports, "ref", ()=>or);
parcelHelpers.export(exports, "refFromURL", ()=>ar);
parcelHelpers.export(exports, "remove", ()=>ur);
parcelHelpers.export(exports, "runTransaction", ()=>_o);
parcelHelpers.export(exports, "serverTimestamp", ()=>ho);
parcelHelpers.export(exports, "set", ()=>dr);
parcelHelpers.export(exports, "setPriority", ()=>_r);
parcelHelpers.export(exports, "setWithPriority", ()=>pr);
parcelHelpers.export(exports, "startAfter", ()=>Or);
parcelHelpers.export(exports, "startAt", ()=>Dr);
parcelHelpers.export(exports, "update", ()=>fr);
var _firebaseApp = require("/scripts/firebaseApp");
var process = require("e4246be5acb84c55");
var global = arguments[3];
const r = !1, o = "${JSCORE_VERSION}", a = function(e, t) {
    if (!e) throw l(t);
}, l = function(e) {
    return new Error("Firebase Database (" + o + ") INTERNAL ASSERT FAILED: " + e);
}, h = function(e) {
    const t = [];
    let n = 0;
    for(let i = 0; i < e.length; i++){
        let s = e.charCodeAt(i);
        s < 128 ? t[n++] = s : s < 2048 ? (t[n++] = s >> 6 | 192, t[n++] = 63 & s | 128) : 55296 == (64512 & s) && i + 1 < e.length && 56320 == (64512 & e.charCodeAt(i + 1)) ? (s = 65536 + ((1023 & s) << 10) + (1023 & e.charCodeAt(++i)), t[n++] = s >> 18 | 240, t[n++] = s >> 12 & 63 | 128, t[n++] = s >> 6 & 63 | 128, t[n++] = 63 & s | 128) : (t[n++] = s >> 12 | 224, t[n++] = s >> 6 & 63 | 128, t[n++] = 63 & s | 128);
    }
    return t;
}, c = {
    byteToCharMap_: null,
    charToByteMap_: null,
    byteToCharMapWebSafe_: null,
    charToByteMapWebSafe_: null,
    ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
    get ENCODED_VALS () {
        return this.ENCODED_VALS_BASE + "+/=";
    },
    get ENCODED_VALS_WEBSAFE () {
        return this.ENCODED_VALS_BASE + "-_.";
    },
    HAS_NATIVE_SUPPORT: "function" == typeof atob,
    encodeByteArray (e, t) {
        if (!Array.isArray(e)) throw Error("encodeByteArray takes an array as a parameter");
        this.init_();
        const n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, i = [];
        for(let t = 0; t < e.length; t += 3){
            const s = e[t], r = t + 1 < e.length, o = r ? e[t + 1] : 0, a = t + 2 < e.length, l = a ? e[t + 2] : 0, h = s >> 2, c = (3 & s) << 4 | o >> 4;
            let u = (15 & o) << 2 | l >> 6, d = 63 & l;
            a || (d = 64, r || (u = 64)), i.push(n[h], n[c], n[u], n[d]);
        }
        return i.join("");
    },
    encodeString (e, t) {
        return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(h(e), t);
    },
    decodeString (e, t) {
        return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : function(e) {
            const t = [];
            let n = 0, i = 0;
            for(; n < e.length;){
                const s = e[n++];
                if (s < 128) t[i++] = String.fromCharCode(s);
                else if (s > 191 && s < 224) {
                    const r = e[n++];
                    t[i++] = String.fromCharCode((31 & s) << 6 | 63 & r);
                } else if (s > 239 && s < 365) {
                    const r = ((7 & s) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536;
                    t[i++] = String.fromCharCode(55296 + (r >> 10)), t[i++] = String.fromCharCode(56320 + (1023 & r));
                } else {
                    const r = e[n++], o = e[n++];
                    t[i++] = String.fromCharCode((15 & s) << 12 | (63 & r) << 6 | 63 & o);
                }
            }
            return t.join("");
        }(this.decodeStringToByteArray(e, t));
    },
    decodeStringToByteArray (e, t) {
        this.init_();
        const n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_, i = [];
        for(let t = 0; t < e.length;){
            const s = n[e.charAt(t++)], r = t < e.length ? n[e.charAt(t)] : 0;
            ++t;
            const o = t < e.length ? n[e.charAt(t)] : 64;
            ++t;
            const a = t < e.length ? n[e.charAt(t)] : 64;
            if (++t, null == s || null == r || null == o || null == a) throw new u;
            const l = s << 2 | r >> 4;
            if (i.push(l), 64 !== o) {
                const e = r << 4 & 240 | o >> 2;
                if (i.push(e), 64 !== a) {
                    const e = o << 6 & 192 | a;
                    i.push(e);
                }
            }
        }
        return i;
    },
    init_ () {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
            for(let e = 0; e < this.ENCODED_VALS.length; e++)this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e);
        }
    }
};
class u extends Error {
    constructor(){
        super(...arguments), this.name = "DecodeBase64StringError";
    }
}
const d = function(e) {
    const t = h(e);
    return c.encodeByteArray(t, !0);
}, _ = function(e) {
    return d(e).replace(/\./g, "");
}, p = function(e) {
    try {
        return c.decodeString(e, !0);
    } catch (e) {
        console.error("base64Decode failed: ", e);
    }
    return null;
};
function f(e) {
    return g(void 0, e);
}
function g(e, t) {
    if (!(t instanceof Object)) return t;
    switch(t.constructor){
        case Date:
            return new Date(t.getTime());
        case Object:
            void 0 === e && (e = {});
            break;
        case Array:
            e = [];
            break;
        default:
            return t;
    }
    for(const n in t)t.hasOwnProperty(n) && "__proto__" !== n && (e[n] = g(e[n], t[n]));
    return e;
}
const m = ()=>(function() {
        if ("undefined" != typeof self) return self;
        if ("undefined" != typeof window) return window;
        if ("undefined" != typeof global) return global;
        throw new Error("Unable to locate global object.");
    })().__FIREBASE_DEFAULTS__, y = ()=>{
    try {
        return m() || (()=>{
            if ("undefined" == typeof process || void 0 === process.env) return;
            const e = undefined;
            return e ? JSON.parse(e) : void 0;
        })() || (()=>{
            if ("undefined" == typeof document) return;
            let e;
            try {
                e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
            } catch (e) {
                return;
            }
            const t = e && p(e[1]);
            return t && JSON.parse(t);
        })();
    } catch (e) {
        return void console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
    }
}, v = (e)=>{
    const t = ((e)=>{
        var t, n;
        return null === (n = null === (t = y()) || void 0 === t ? void 0 : t.emulatorHosts) || void 0 === n ? void 0 : n[e];
    })(e);
    if (!t) return;
    const n = t.lastIndexOf(":");
    if (n <= 0 || n + 1 === t.length) throw new Error(`Invalid host ${t} with no separate hostname and port!`);
    const i = parseInt(t.substring(n + 1), 10);
    return "[" === t[0] ? [
        t.substring(1, n - 1),
        i
    ] : [
        t.substring(0, n),
        i
    ];
};
class C {
    constructor(){
        this.reject = ()=>{}, this.resolve = ()=>{}, this.promise = new Promise((e, t)=>{
            this.resolve = e, this.reject = t;
        });
    }
    wrapCallback(e) {
        return (t, n)=>{
            t ? this.reject(t) : this.resolve(n), "function" == typeof e && (this.promise.catch(()=>{}), 1 === e.length ? e(t) : e(t, n));
        };
    }
}
function w() {
    return "undefined" != typeof window && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test("undefined" != typeof navigator && "string" == typeof navigator.userAgent ? navigator.userAgent : "");
}
function T() {
    return !0 === r;
}
function b(e) {
    return JSON.parse(e);
}
function E(e) {
    return JSON.stringify(e);
}
const I = function(e) {
    let t = {}, n = {}, i = {}, s = "";
    try {
        const r = e.split(".");
        t = b(p(r[0]) || ""), n = b(p(r[1]) || ""), s = r[2], i = n.d || {}, delete n.d;
    } catch (e) {}
    return {
        header: t,
        claims: n,
        data: i,
        signature: s
    };
};
function S(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
}
function k(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0;
}
function N(e) {
    for(const t in e)if (Object.prototype.hasOwnProperty.call(e, t)) return !1;
    return !0;
}
function P(e, t, n) {
    const i = {};
    for(const s in e)Object.prototype.hasOwnProperty.call(e, s) && (i[s] = t.call(n, e[s], s, e));
    return i;
}
class x {
    constructor(){
        this.chain_ = [], this.buf_ = [], this.W_ = [], this.pad_ = [], this.inbuf_ = 0, this.total_ = 0, this.blockSize = 64, this.pad_[0] = 128;
        for(let e = 1; e < this.blockSize; ++e)this.pad_[e] = 0;
        this.reset();
    }
    reset() {
        this.chain_[0] = 1732584193, this.chain_[1] = 4023233417, this.chain_[2] = 2562383102, this.chain_[3] = 271733878, this.chain_[4] = 3285377520, this.inbuf_ = 0, this.total_ = 0;
    }
    compress_(e, t) {
        t || (t = 0);
        const n = this.W_;
        if ("string" == typeof e) for(let i = 0; i < 16; i++)n[i] = e.charCodeAt(t) << 24 | e.charCodeAt(t + 1) << 16 | e.charCodeAt(t + 2) << 8 | e.charCodeAt(t + 3), t += 4;
        else for(let i = 0; i < 16; i++)n[i] = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3], t += 4;
        for(let e = 16; e < 80; e++){
            const t = n[e - 3] ^ n[e - 8] ^ n[e - 14] ^ n[e - 16];
            n[e] = 4294967295 & (t << 1 | t >>> 31);
        }
        let i, s, r = this.chain_[0], o = this.chain_[1], a = this.chain_[2], l = this.chain_[3], h = this.chain_[4];
        for(let e = 0; e < 80; e++){
            e < 40 ? e < 20 ? (i = l ^ o & (a ^ l), s = 1518500249) : (i = o ^ a ^ l, s = 1859775393) : e < 60 ? (i = o & a | l & (o | a), s = 2400959708) : (i = o ^ a ^ l, s = 3395469782);
            const t = (r << 5 | r >>> 27) + i + h + s + n[e] & 4294967295;
            h = l, l = a, a = 4294967295 & (o << 30 | o >>> 2), o = r, r = t;
        }
        this.chain_[0] = this.chain_[0] + r & 4294967295, this.chain_[1] = this.chain_[1] + o & 4294967295, this.chain_[2] = this.chain_[2] + a & 4294967295, this.chain_[3] = this.chain_[3] + l & 4294967295, this.chain_[4] = this.chain_[4] + h & 4294967295;
    }
    update(e, t) {
        if (null == e) return;
        void 0 === t && (t = e.length);
        const n = t - this.blockSize;
        let i = 0;
        const s = this.buf_;
        let r = this.inbuf_;
        for(; i < t;){
            if (0 === r) for(; i <= n;)this.compress_(e, i), i += this.blockSize;
            if ("string" == typeof e) {
                for(; i < t;)if (s[r] = e.charCodeAt(i), ++r, ++i, r === this.blockSize) {
                    this.compress_(s), r = 0;
                    break;
                }
            } else for(; i < t;)if (s[r] = e[i], ++r, ++i, r === this.blockSize) {
                this.compress_(s), r = 0;
                break;
            }
        }
        this.inbuf_ = r, this.total_ += t;
    }
    digest() {
        const e = [];
        let t = 8 * this.total_;
        this.inbuf_ < 56 ? this.update(this.pad_, 56 - this.inbuf_) : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        for(let e = this.blockSize - 1; e >= 56; e--)this.buf_[e] = 255 & t, t /= 256;
        this.compress_(this.buf_);
        let n = 0;
        for(let t = 0; t < 5; t++)for(let i = 24; i >= 0; i -= 8)e[n] = this.chain_[t] >> i & 255, ++n;
        return e;
    }
}
function R(e, t) {
    return `${e} failed: ${t} argument `;
}
const D = function(e) {
    let t = 0;
    for(let n = 0; n < e.length; n++){
        const i = e.charCodeAt(n);
        i < 128 ? t++ : i < 2048 ? t += 2 : i >= 55296 && i <= 56319 ? (t += 4, n++) : t += 3;
    }
    return t;
};
function A(e) {
    return e && e._delegate ? e._delegate : e;
}
class O {
    constructor(e, t, n){
        this.name = e, this.instanceFactory = t, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
    }
    setInstantiationMode(e) {
        return this.instantiationMode = e, this;
    }
    setMultipleInstances(e) {
        return this.multipleInstances = e, this;
    }
    setServiceProps(e) {
        return this.serviceProps = e, this;
    }
    setInstanceCreatedCallback(e) {
        return this.onInstanceCreated = e, this;
    }
}
var L;
!function(e) {
    e[e.DEBUG = 0] = "DEBUG", e[e.VERBOSE = 1] = "VERBOSE", e[e.INFO = 2] = "INFO", e[e.WARN = 3] = "WARN", e[e.ERROR = 4] = "ERROR", e[e.SILENT = 5] = "SILENT";
}(L || (L = {}));
const F = {
    debug: L.DEBUG,
    verbose: L.VERBOSE,
    info: L.INFO,
    warn: L.WARN,
    error: L.ERROR,
    silent: L.SILENT
}, M = L.INFO, q = {
    [L.DEBUG]: "log",
    [L.VERBOSE]: "log",
    [L.INFO]: "info",
    [L.WARN]: "warn",
    [L.ERROR]: "error"
}, W = (e, t, ...n)=>{
    if (t < e.logLevel) return;
    const i = (new Date).toISOString(), s = q[t];
    if (!s) throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);
    console[s](`[${i}]  ${e.name}:`, ...n);
};
const U = "@firebase/database";
let B = "";
function j(e) {
    B = e;
}
class H {
    constructor(e){
        this.domStorage_ = e, this.prefix_ = "firebase:";
    }
    set(e, t) {
        null == t ? this.domStorage_.removeItem(this.prefixedName_(e)) : this.domStorage_.setItem(this.prefixedName_(e), E(t));
    }
    get(e) {
        const t = this.domStorage_.getItem(this.prefixedName_(e));
        return null == t ? null : b(t);
    }
    remove(e) {
        this.domStorage_.removeItem(this.prefixedName_(e));
    }
    prefixedName_(e) {
        return this.prefix_ + e;
    }
    toString() {
        return this.domStorage_.toString();
    }
}
class V {
    constructor(){
        this.cache_ = {}, this.isInMemoryStorage = !0;
    }
    set(e, t) {
        null == t ? delete this.cache_[e] : this.cache_[e] = t;
    }
    get(e) {
        return S(this.cache_, e) ? this.cache_[e] : null;
    }
    remove(e) {
        delete this.cache_[e];
    }
}
const z = function(e) {
    try {
        if ("undefined" != typeof window && void 0 !== window[e]) {
            const t = window[e];
            return t.setItem("firebase:sentinel", "cache"), t.removeItem("firebase:sentinel"), new H(t);
        }
    } catch (e) {}
    return new V;
}, Y = z("localStorage"), K = z("sessionStorage"), Q = new class {
    constructor(e){
        this.name = e, this._logLevel = M, this._logHandler = W, this._userLogHandler = null;
    }
    get logLevel() {
        return this._logLevel;
    }
    set logLevel(e) {
        if (!(e in L)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
        this._logLevel = e;
    }
    setLogLevel(e) {
        this._logLevel = "string" == typeof e ? F[e] : e;
    }
    get logHandler() {
        return this._logHandler;
    }
    set logHandler(e) {
        if ("function" != typeof e) throw new TypeError("Value assigned to `logHandler` must be a function");
        this._logHandler = e;
    }
    get userLogHandler() {
        return this._userLogHandler;
    }
    set userLogHandler(e) {
        this._userLogHandler = e;
    }
    debug(...e) {
        this._userLogHandler && this._userLogHandler(this, L.DEBUG, ...e), this._logHandler(this, L.DEBUG, ...e);
    }
    log(...e) {
        this._userLogHandler && this._userLogHandler(this, L.VERBOSE, ...e), this._logHandler(this, L.VERBOSE, ...e);
    }
    info(...e) {
        this._userLogHandler && this._userLogHandler(this, L.INFO, ...e), this._logHandler(this, L.INFO, ...e);
    }
    warn(...e) {
        this._userLogHandler && this._userLogHandler(this, L.WARN, ...e), this._logHandler(this, L.WARN, ...e);
    }
    error(...e) {
        this._userLogHandler && this._userLogHandler(this, L.ERROR, ...e), this._logHandler(this, L.ERROR, ...e);
    }
}("@firebase/database"), $ = function() {
    let e = 1;
    return function() {
        return e++;
    };
}(), G = function(e) {
    const t = function(e) {
        const t = [];
        let n = 0;
        for(let i = 0; i < e.length; i++){
            let s = e.charCodeAt(i);
            if (s >= 55296 && s <= 56319) {
                const t = s - 55296;
                i++, a(i < e.length, "Surrogate pair missing trail surrogate."), s = 65536 + (t << 10) + (e.charCodeAt(i) - 56320);
            }
            s < 128 ? t[n++] = s : s < 2048 ? (t[n++] = s >> 6 | 192, t[n++] = 63 & s | 128) : s < 65536 ? (t[n++] = s >> 12 | 224, t[n++] = s >> 6 & 63 | 128, t[n++] = 63 & s | 128) : (t[n++] = s >> 18 | 240, t[n++] = s >> 12 & 63 | 128, t[n++] = s >> 6 & 63 | 128, t[n++] = 63 & s | 128);
        }
        return t;
    }(e), n = new x;
    n.update(t);
    const i = n.digest();
    return c.encodeByteArray(i);
}, J = function(...e) {
    let t = "";
    for(let n = 0; n < e.length; n++){
        const i = e[n];
        Array.isArray(i) || i && "object" == typeof i && "number" == typeof i.length ? t += J.apply(null, i) : t += "object" == typeof i ? E(i) : i, t += " ";
    }
    return t;
};
let X = null, Z = !0;
const ee = function(e, t) {
    a(!t || !0 === e || !1 === e, "Can't turn on custom loggers persistently."), !0 === e ? (Q.logLevel = L.VERBOSE, X = Q.log.bind(Q), t && K.set("logging_enabled", !0)) : "function" == typeof e ? X = e : (X = null, K.remove("logging_enabled"));
}, te = function(...e) {
    if (!0 === Z && (Z = !1, null === X && !0 === K.get("logging_enabled") && ee(!0)), X) {
        const t = J.apply(null, e);
        X(t);
    }
}, ne = function(e) {
    return function(...t) {
        te(e, ...t);
    };
}, ie = function(...e) {
    const t = "FIREBASE INTERNAL ERROR: " + J(...e);
    Q.error(t);
}, se = function(...e) {
    const t = `FIREBASE FATAL ERROR: ${J(...e)}`;
    throw Q.error(t), new Error(t);
}, re = function(...e) {
    const t = "FIREBASE WARNING: " + J(...e);
    Q.warn(t);
}, oe = function(e) {
    return "number" == typeof e && (e != e || e === Number.POSITIVE_INFINITY || e === Number.NEGATIVE_INFINITY);
}, ae = "[MIN_NAME]", le = "[MAX_NAME]", he = function(e, t) {
    if (e === t) return 0;
    if (e === ae || t === le) return -1;
    if (t === ae || e === le) return 1;
    {
        const n = me(e), i = me(t);
        return null !== n ? null !== i ? n - i == 0 ? e.length - t.length : n - i : -1 : null !== i ? 1 : e < t ? -1 : 1;
    }
}, ce = function(e, t) {
    return e === t ? 0 : e < t ? -1 : 1;
}, ue = function(e, t) {
    if (t && e in t) return t[e];
    throw new Error("Missing required key (" + e + ") in object: " + E(t));
}, de = function(e) {
    if ("object" != typeof e || null === e) return E(e);
    const t = [];
    for(const n in e)t.push(n);
    t.sort();
    let n = "{";
    for(let i = 0; i < t.length; i++)0 !== i && (n += ","), n += E(t[i]), n += ":", n += de(e[t[i]]);
    return n += "}", n;
}, _e = function(e, t) {
    const n = e.length;
    if (n <= t) return [
        e
    ];
    const i = [];
    for(let s = 0; s < n; s += t)s + t > n ? i.push(e.substring(s, n)) : i.push(e.substring(s, s + t));
    return i;
};
function pe(e, t) {
    for(const n in e)e.hasOwnProperty(n) && t(n, e[n]);
}
const fe = function(e) {
    a(!oe(e), "Invalid JSON number");
    const t = 1023;
    let n, i, s, r, o;
    0 === e ? (i = 0, s = 0, n = 1 / e == -1 / 0 ? 1 : 0) : (n = e < 0, (e = Math.abs(e)) >= Math.pow(2, -1022) ? (r = Math.min(Math.floor(Math.log(e) / Math.LN2), t), i = r + t, s = Math.round(e * Math.pow(2, 52 - r) - Math.pow(2, 52))) : (i = 0, s = Math.round(e / Math.pow(2, -1074))));
    const l = [];
    for(o = 52; o; o -= 1)l.push(s % 2 ? 1 : 0), s = Math.floor(s / 2);
    for(o = 11; o; o -= 1)l.push(i % 2 ? 1 : 0), i = Math.floor(i / 2);
    l.push(n ? 1 : 0), l.reverse();
    const h = l.join("");
    let c = "";
    for(o = 0; o < 64; o += 8){
        let e = parseInt(h.substr(o, 8), 2).toString(16);
        1 === e.length && (e = "0" + e), c += e;
    }
    return c.toLowerCase();
};
const ge = new RegExp("^-?(0*)\\d{1,10}$"), me = function(e) {
    if (ge.test(e)) {
        const t = Number(e);
        if (t >= -2147483648 && t <= 2147483647) return t;
    }
    return null;
}, ye = function(e) {
    try {
        e();
    } catch (e) {
        setTimeout(()=>{
            const t = e.stack || "";
            throw re("Exception was thrown by user callback.", t), e;
        }, Math.floor(0));
    }
}, ve = function(e, t) {
    const n = setTimeout(e, t);
    return "number" == typeof n && "undefined" != typeof Deno && Deno.unrefTimer ? Deno.unrefTimer(n) : "object" == typeof n && n.unref && n.unref(), n;
};
class Ce {
    constructor(e, t){
        this.appName_ = e, this.appCheckProvider = t, this.appCheck = null == t ? void 0 : t.getImmediate({
            optional: !0
        }), this.appCheck || null == t || t.get().then((e)=>this.appCheck = e);
    }
    getToken(e) {
        return this.appCheck ? this.appCheck.getToken(e) : new Promise((t, n)=>{
            setTimeout(()=>{
                this.appCheck ? this.getToken(e).then(t, n) : t(null);
            }, 0);
        });
    }
    addTokenChangeListener(e) {
        var t;
        null === (t = this.appCheckProvider) || void 0 === t || t.get().then((t)=>t.addTokenListener(e));
    }
    notifyForInvalidToken() {
        re(`Provided AppCheck credentials for the app named "${this.appName_}" are invalid. This usually indicates your app was not initialized correctly.`);
    }
}
class we {
    constructor(e, t, n){
        this.appName_ = e, this.firebaseOptions_ = t, this.authProvider_ = n, this.auth_ = null, this.auth_ = n.getImmediate({
            optional: !0
        }), this.auth_ || n.onInit((e)=>this.auth_ = e);
    }
    getToken(e) {
        return this.auth_ ? this.auth_.getToken(e).catch((e)=>e && "auth/token-not-initialized" === e.code ? (te("Got auth/token-not-initialized error.  Treating as null token."), null) : Promise.reject(e)) : new Promise((t, n)=>{
            setTimeout(()=>{
                this.auth_ ? this.getToken(e).then(t, n) : t(null);
            }, 0);
        });
    }
    addTokenChangeListener(e) {
        this.auth_ ? this.auth_.addAuthTokenListener(e) : this.authProvider_.get().then((t)=>t.addAuthTokenListener(e));
    }
    removeTokenChangeListener(e) {
        this.authProvider_.get().then((t)=>t.removeAuthTokenListener(e));
    }
    notifyForInvalidToken() {
        let e = 'Provided authentication credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly. ';
        "credential" in this.firebaseOptions_ ? e += 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : "serviceAccount" in this.firebaseOptions_ ? e += 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : e += 'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.', re(e);
    }
}
class Te {
    constructor(e){
        this.accessToken = e;
    }
    getToken(e) {
        return Promise.resolve({
            accessToken: this.accessToken
        });
    }
    addTokenChangeListener(e) {
        e(this.accessToken);
    }
    removeTokenChangeListener(e) {}
    notifyForInvalidToken() {}
}
Te.OWNER = "owner";
const be = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;
class Ee {
    constructor(e, t, n, i, s = !1, r = "", o = !1, a = !1){
        this.secure = t, this.namespace = n, this.webSocketOnly = i, this.nodeAdmin = s, this.persistenceKey = r, this.includeNamespaceInQueryParams = o, this.isUsingEmulator = a, this._host = e.toLowerCase(), this._domain = this._host.substr(this._host.indexOf(".") + 1), this.internalHost = Y.get("host:" + e) || this._host;
    }
    isCacheableHost() {
        return "s-" === this.internalHost.substr(0, 2);
    }
    isCustomHost() {
        return "firebaseio.com" !== this._domain && "firebaseio-demo.com" !== this._domain;
    }
    get host() {
        return this._host;
    }
    set host(e) {
        e !== this.internalHost && (this.internalHost = e, this.isCacheableHost() && Y.set("host:" + this._host, this.internalHost));
    }
    toString() {
        let e = this.toURLString();
        return this.persistenceKey && (e += "<" + this.persistenceKey + ">"), e;
    }
    toURLString() {
        const e = this.secure ? "https://" : "http://", t = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : "";
        return `${e}${this.host}/${t}`;
    }
}
function Ie(e, t, n) {
    let i;
    if (a("string" == typeof t, "typeof type must == string"), a("object" == typeof n, "typeof params must == object"), "websocket" === t) i = (e.secure ? "wss://" : "ws://") + e.internalHost + "/.ws?";
    else {
        if ("long_polling" !== t) throw new Error("Unknown connection type: " + t);
        i = (e.secure ? "https://" : "http://") + e.internalHost + "/.lp?";
    }
    (function(e) {
        return e.host !== e.internalHost || e.isCustomHost() || e.includeNamespaceInQueryParams;
    })(e) && (n.ns = e.namespace);
    const s = [];
    return pe(n, (e, t)=>{
        s.push(e + "=" + t);
    }), i + s.join("&");
}
class Se {
    constructor(){
        this.counters_ = {};
    }
    incrementCounter(e, t = 1) {
        S(this.counters_, e) || (this.counters_[e] = 0), this.counters_[e] += t;
    }
    get() {
        return f(this.counters_);
    }
}
const ke = {}, Ne = {};
function Pe(e) {
    const t = e.toString();
    return ke[t] || (ke[t] = new Se), ke[t];
}
class xe {
    constructor(e){
        this.onMessage_ = e, this.pendingResponses = [], this.currentResponseNum = 0, this.closeAfterResponse = -1, this.onClose = null;
    }
    closeAfter(e, t) {
        this.closeAfterResponse = e, this.onClose = t, this.closeAfterResponse < this.currentResponseNum && (this.onClose(), this.onClose = null);
    }
    handleResponse(e, t) {
        for(this.pendingResponses[e] = t; this.pendingResponses[this.currentResponseNum];){
            const e = this.pendingResponses[this.currentResponseNum];
            delete this.pendingResponses[this.currentResponseNum];
            for(let t = 0; t < e.length; ++t)e[t] && ye(()=>{
                this.onMessage_(e[t]);
            });
            if (this.currentResponseNum === this.closeAfterResponse) {
                this.onClose && (this.onClose(), this.onClose = null);
                break;
            }
            this.currentResponseNum++;
        }
    }
}
class Re {
    constructor(e, t, n, i, s, r, o){
        this.connId = e, this.repoInfo = t, this.applicationId = n, this.appCheckToken = i, this.authToken = s, this.transportSessionId = r, this.lastSessionId = o, this.bytesSent = 0, this.bytesReceived = 0, this.everConnected_ = !1, this.log_ = ne(e), this.stats_ = Pe(t), this.urlFn = (e)=>(this.appCheckToken && (e.ac = this.appCheckToken), Ie(t, "long_polling", e));
    }
    open(e, t) {
        this.curSegmentNum = 0, this.onDisconnect_ = t, this.myPacketOrderer = new xe(e), this.isClosed_ = !1, this.connectTimeoutTimer_ = setTimeout(()=>{
            this.log_("Timed out trying to connect."), this.onClosed_(), this.connectTimeoutTimer_ = null;
        }, Math.floor(3e4)), function(e) {
            if ("complete" === document.readyState) e();
            else {
                let t = !1;
                const n = function() {
                    document.body ? t || (t = !0, e()) : setTimeout(n, Math.floor(10));
                };
                document.addEventListener ? (document.addEventListener("DOMContentLoaded", n, !1), window.addEventListener("load", n, !1)) : document.attachEvent && (document.attachEvent("onreadystatechange", ()=>{
                    "complete" === document.readyState && n();
                }), window.attachEvent("onload", n));
            }
        }(()=>{
            if (this.isClosed_) return;
            this.scriptTagHolder = new De((...e)=>{
                const [t, n, i, s, r] = e;
                if (this.incrementIncomingBytes_(e), this.scriptTagHolder) {
                    if (this.connectTimeoutTimer_ && (clearTimeout(this.connectTimeoutTimer_), this.connectTimeoutTimer_ = null), this.everConnected_ = !0, "start" === t) this.id = n, this.password = i;
                    else {
                        if ("close" !== t) throw new Error("Unrecognized command received: " + t);
                        n ? (this.scriptTagHolder.sendNewPolls = !1, this.myPacketOrderer.closeAfter(n, ()=>{
                            this.onClosed_();
                        })) : this.onClosed_();
                    }
                }
            }, (...e)=>{
                const [t, n] = e;
                this.incrementIncomingBytes_(e), this.myPacketOrderer.handleResponse(t, n);
            }, ()=>{
                this.onClosed_();
            }, this.urlFn);
            const e = {
                start: "t"
            };
            e.ser = Math.floor(1e8 * Math.random()), this.scriptTagHolder.uniqueCallbackIdentifier && (e.cb = this.scriptTagHolder.uniqueCallbackIdentifier), e.v = "5", this.transportSessionId && (e.s = this.transportSessionId), this.lastSessionId && (e.ls = this.lastSessionId), this.applicationId && (e.p = this.applicationId), this.appCheckToken && (e.ac = this.appCheckToken), "undefined" != typeof location && location.hostname && be.test(location.hostname) && (e.r = "f");
            const t = this.urlFn(e);
            this.log_("Connecting via long-poll to " + t), this.scriptTagHolder.addTag(t, ()=>{});
        });
    }
    start() {
        this.scriptTagHolder.startLongPoll(this.id, this.password), this.addDisconnectPingFrame(this.id, this.password);
    }
    static forceAllow() {
        Re.forceAllow_ = !0;
    }
    static forceDisallow() {
        Re.forceDisallow_ = !0;
    }
    static isAvailable() {
        return !!Re.forceAllow_ || !(Re.forceDisallow_ || "undefined" == typeof document || null == document.createElement || "object" == typeof window && window.chrome && window.chrome.extension && !/^chrome/.test(window.location.href) || "object" == typeof Windows && "object" == typeof Windows.UI);
    }
    markConnectionHealthy() {}
    shutdown_() {
        this.isClosed_ = !0, this.scriptTagHolder && (this.scriptTagHolder.close(), this.scriptTagHolder = null), this.myDisconnFrame && (document.body.removeChild(this.myDisconnFrame), this.myDisconnFrame = null), this.connectTimeoutTimer_ && (clearTimeout(this.connectTimeoutTimer_), this.connectTimeoutTimer_ = null);
    }
    onClosed_() {
        this.isClosed_ || (this.log_("Longpoll is closing itself"), this.shutdown_(), this.onDisconnect_ && (this.onDisconnect_(this.everConnected_), this.onDisconnect_ = null));
    }
    close() {
        this.isClosed_ || (this.log_("Longpoll is being closed."), this.shutdown_());
    }
    send(e) {
        const t = E(e);
        this.bytesSent += t.length, this.stats_.incrementCounter("bytes_sent", t.length);
        const n = d(t), i = _e(n, 1840);
        for(let e = 0; e < i.length; e++)this.scriptTagHolder.enqueueSegment(this.curSegmentNum, i.length, i[e]), this.curSegmentNum++;
    }
    addDisconnectPingFrame(e, t) {
        this.myDisconnFrame = document.createElement("iframe");
        const n = {
            dframe: "t"
        };
        n.id = e, n.pw = t, this.myDisconnFrame.src = this.urlFn(n), this.myDisconnFrame.style.display = "none", document.body.appendChild(this.myDisconnFrame);
    }
    incrementIncomingBytes_(e) {
        const t = E(e).length;
        this.bytesReceived += t, this.stats_.incrementCounter("bytes_received", t);
    }
}
class De {
    constructor(e, t, n, i){
        this.onDisconnect = n, this.urlFn = i, this.outstandingRequests = new Set, this.pendingSegs = [], this.currentSerial = Math.floor(1e8 * Math.random()), this.sendNewPolls = !0;
        {
            this.uniqueCallbackIdentifier = $(), window["pLPCommand" + this.uniqueCallbackIdentifier] = e, window["pRTLPCB" + this.uniqueCallbackIdentifier] = t, this.myIFrame = De.createIFrame_();
            let n = "";
            if (this.myIFrame.src && "javascript:" === this.myIFrame.src.substr(0, 11)) n = '<script>document.domain="' + document.domain + '";</\script>';
            const i = "<html><body>" + n + "</body></html>";
            try {
                this.myIFrame.doc.open(), this.myIFrame.doc.write(i), this.myIFrame.doc.close();
            } catch (e) {
                te("frame writing exception"), e.stack && te(e.stack), te(e);
            }
        }
    }
    static createIFrame_() {
        const e = document.createElement("iframe");
        if (e.style.display = "none", !document.body) throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
        document.body.appendChild(e);
        try {
            e.contentWindow.document || te("No IE domain setting required");
        } catch (t) {
            const n = document.domain;
            e.src = "javascript:void((function(){document.open();document.domain='" + n + "';document.close();})())";
        }
        return e.contentDocument ? e.doc = e.contentDocument : e.contentWindow ? e.doc = e.contentWindow.document : e.document && (e.doc = e.document), e;
    }
    close() {
        this.alive = !1, this.myIFrame && (this.myIFrame.doc.body.textContent = "", setTimeout(()=>{
            null !== this.myIFrame && (document.body.removeChild(this.myIFrame), this.myIFrame = null);
        }, Math.floor(0)));
        const e = this.onDisconnect;
        e && (this.onDisconnect = null, e());
    }
    startLongPoll(e, t) {
        for(this.myID = e, this.myPW = t, this.alive = !0; this.newRequest_(););
    }
    newRequest_() {
        if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {
            this.currentSerial++;
            const e = {};
            e.id = this.myID, e.pw = this.myPW, e.ser = this.currentSerial;
            let t = this.urlFn(e), n = "", i = 0;
            for(; this.pendingSegs.length > 0;){
                if (!(this.pendingSegs[0].d.length + 30 + n.length <= 1870)) break;
                {
                    const e = this.pendingSegs.shift();
                    n = n + "&seg" + i + "=" + e.seg + "&ts" + i + "=" + e.ts + "&d" + i + "=" + e.d, i++;
                }
            }
            return t += n, this.addLongPollTag_(t, this.currentSerial), !0;
        }
        return !1;
    }
    enqueueSegment(e, t, n) {
        this.pendingSegs.push({
            seg: e,
            ts: t,
            d: n
        }), this.alive && this.newRequest_();
    }
    addLongPollTag_(e, t) {
        this.outstandingRequests.add(t);
        const n = ()=>{
            this.outstandingRequests.delete(t), this.newRequest_();
        }, i = setTimeout(n, Math.floor(25e3));
        this.addTag(e, ()=>{
            clearTimeout(i), n();
        });
    }
    addTag(e, t) {
        setTimeout(()=>{
            try {
                if (!this.sendNewPolls) return;
                const n = this.myIFrame.doc.createElement("script");
                n.type = "text/javascript", n.async = !0, n.src = e, n.onload = n.onreadystatechange = function() {
                    const e = n.readyState;
                    e && "loaded" !== e && "complete" !== e || (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild(n), t());
                }, n.onerror = ()=>{
                    te("Long-poll script failed to load: " + e), this.sendNewPolls = !1, this.close();
                }, this.myIFrame.doc.body.appendChild(n);
            } catch (e) {}
        }, Math.floor(1));
    }
}
let Ae = null;
"undefined" != typeof MozWebSocket ? Ae = MozWebSocket : "undefined" != typeof WebSocket && (Ae = WebSocket);
class Oe {
    constructor(e, t, n, i, s, r, o){
        this.connId = e, this.applicationId = n, this.appCheckToken = i, this.authToken = s, this.keepaliveTimer = null, this.frames = null, this.totalFrames = 0, this.bytesSent = 0, this.bytesReceived = 0, this.log_ = ne(this.connId), this.stats_ = Pe(t), this.connURL = Oe.connectionURL_(t, r, o, i, n), this.nodeAdmin = t.nodeAdmin;
    }
    static connectionURL_(e, t, n, i, s) {
        const r = {
            v: "5"
        };
        return "undefined" != typeof location && location.hostname && be.test(location.hostname) && (r.r = "f"), t && (r.s = t), n && (r.ls = n), i && (r.ac = i), s && (r.p = s), Ie(e, "websocket", r);
    }
    open(e, t) {
        this.onDisconnect = t, this.onMessage = e, this.log_("Websocket connecting to " + this.connURL), this.everConnected_ = !1, Y.set("previous_websocket_failure", !0);
        try {
            let e;
            T(), this.mySock = new Ae(this.connURL, [], e);
        } catch (e) {
            this.log_("Error instantiating WebSocket.");
            const t = e.message || e.data;
            return t && this.log_(t), void this.onClosed_();
        }
        this.mySock.onopen = ()=>{
            this.log_("Websocket connected."), this.everConnected_ = !0;
        }, this.mySock.onclose = ()=>{
            this.log_("Websocket connection was disconnected."), this.mySock = null, this.onClosed_();
        }, this.mySock.onmessage = (e)=>{
            this.handleIncomingFrame(e);
        }, this.mySock.onerror = (e)=>{
            this.log_("WebSocket error.  Closing connection.");
            const t = e.message || e.data;
            t && this.log_(t), this.onClosed_();
        };
    }
    start() {}
    static forceDisallow() {
        Oe.forceDisallow_ = !0;
    }
    static isAvailable() {
        let e = !1;
        if ("undefined" != typeof navigator && navigator.userAgent) {
            const t = /Android ([0-9]{0,}\.[0-9]{0,})/, n = navigator.userAgent.match(t);
            n && n.length > 1 && parseFloat(n[1]) < 4.4 && (e = !0);
        }
        return !e && null !== Ae && !Oe.forceDisallow_;
    }
    static previouslyFailed() {
        return Y.isInMemoryStorage || !0 === Y.get("previous_websocket_failure");
    }
    markConnectionHealthy() {
        Y.remove("previous_websocket_failure");
    }
    appendFrame_(e) {
        if (this.frames.push(e), this.frames.length === this.totalFrames) {
            const e = this.frames.join("");
            this.frames = null;
            const t = b(e);
            this.onMessage(t);
        }
    }
    handleNewFrameCount_(e) {
        this.totalFrames = e, this.frames = [];
    }
    extractFrameCount_(e) {
        if (a(null === this.frames, "We already have a frame buffer"), e.length <= 6) {
            const t = Number(e);
            if (!isNaN(t)) return this.handleNewFrameCount_(t), null;
        }
        return this.handleNewFrameCount_(1), e;
    }
    handleIncomingFrame(e) {
        if (null === this.mySock) return;
        const t = e.data;
        if (this.bytesReceived += t.length, this.stats_.incrementCounter("bytes_received", t.length), this.resetKeepAlive(), null !== this.frames) this.appendFrame_(t);
        else {
            const e = this.extractFrameCount_(t);
            null !== e && this.appendFrame_(e);
        }
    }
    send(e) {
        this.resetKeepAlive();
        const t = E(e);
        this.bytesSent += t.length, this.stats_.incrementCounter("bytes_sent", t.length);
        const n = _e(t, 16384);
        n.length > 1 && this.sendString_(String(n.length));
        for(let e = 0; e < n.length; e++)this.sendString_(n[e]);
    }
    shutdown_() {
        this.isClosed_ = !0, this.keepaliveTimer && (clearInterval(this.keepaliveTimer), this.keepaliveTimer = null), this.mySock && (this.mySock.close(), this.mySock = null);
    }
    onClosed_() {
        this.isClosed_ || (this.log_("WebSocket is closing itself"), this.shutdown_(), this.onDisconnect && (this.onDisconnect(this.everConnected_), this.onDisconnect = null));
    }
    close() {
        this.isClosed_ || (this.log_("WebSocket is being closed"), this.shutdown_());
    }
    resetKeepAlive() {
        clearInterval(this.keepaliveTimer), this.keepaliveTimer = setInterval(()=>{
            this.mySock && this.sendString_("0"), this.resetKeepAlive();
        }, Math.floor(45e3));
    }
    sendString_(e) {
        try {
            this.mySock.send(e);
        } catch (e) {
            this.log_("Exception thrown from WebSocket.send():", e.message || e.data, "Closing connection."), setTimeout(this.onClosed_.bind(this), 0);
        }
    }
}
Oe.responsesRequiredToBeHealthy = 2, Oe.healthyTimeout = 3e4;
class Le {
    constructor(e){
        this.initTransports_(e);
    }
    static get ALL_TRANSPORTS() {
        return [
            Re,
            Oe
        ];
    }
    static get IS_TRANSPORT_INITIALIZED() {
        return this.globalTransportInitialized_;
    }
    initTransports_(e) {
        const t = Oe && Oe.isAvailable();
        let n = t && !Oe.previouslyFailed();
        if (e.webSocketOnly && (t || re("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."), n = !0), n) this.transports_ = [
            Oe
        ];
        else {
            const e = this.transports_ = [];
            for (const t of Le.ALL_TRANSPORTS)t && t.isAvailable() && e.push(t);
            Le.globalTransportInitialized_ = !0;
        }
    }
    initialTransport() {
        if (this.transports_.length > 0) return this.transports_[0];
        throw new Error("No transports available");
    }
    upgradeTransport() {
        return this.transports_.length > 1 ? this.transports_[1] : null;
    }
}
Le.globalTransportInitialized_ = !1;
class Fe {
    constructor(e, t, n, i, s, r, o, a, l, h){
        this.id = e, this.repoInfo_ = t, this.applicationId_ = n, this.appCheckToken_ = i, this.authToken_ = s, this.onMessage_ = r, this.onReady_ = o, this.onDisconnect_ = a, this.onKill_ = l, this.lastSessionId = h, this.connectionCount = 0, this.pendingDataMessages = [], this.state_ = 0, this.log_ = ne("c:" + this.id + ":"), this.transportManager_ = new Le(t), this.log_("Connection created"), this.start_();
    }
    start_() {
        const e = this.transportManager_.initialTransport();
        this.conn_ = new e(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId), this.primaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0;
        const t = this.connReceiver_(this.conn_), n = this.disconnReceiver_(this.conn_);
        this.tx_ = this.conn_, this.rx_ = this.conn_, this.secondaryConn_ = null, this.isHealthy_ = !1, setTimeout(()=>{
            this.conn_ && this.conn_.open(t, n);
        }, Math.floor(0));
        const i = e.healthyTimeout || 0;
        i > 0 && (this.healthyTimeout_ = ve(()=>{
            this.healthyTimeout_ = null, this.isHealthy_ || (this.conn_ && this.conn_.bytesReceived > 102400 ? (this.log_("Connection exceeded healthy timeout but has received " + this.conn_.bytesReceived + " bytes.  Marking connection healthy."), this.isHealthy_ = !0, this.conn_.markConnectionHealthy()) : this.conn_ && this.conn_.bytesSent > 10240 ? this.log_("Connection exceeded healthy timeout but has sent " + this.conn_.bytesSent + " bytes.  Leaving connection alive.") : (this.log_("Closing unhealthy connection after timeout."), this.close()));
        }, Math.floor(i)));
    }
    nextTransportId_() {
        return "c:" + this.id + ":" + this.connectionCount++;
    }
    disconnReceiver_(e) {
        return (t)=>{
            e === this.conn_ ? this.onConnectionLost_(t) : e === this.secondaryConn_ ? (this.log_("Secondary connection lost."), this.onSecondaryConnectionLost_()) : this.log_("closing an old connection");
        };
    }
    connReceiver_(e) {
        return (t)=>{
            2 !== this.state_ && (e === this.rx_ ? this.onPrimaryMessageReceived_(t) : e === this.secondaryConn_ ? this.onSecondaryMessageReceived_(t) : this.log_("message on old connection"));
        };
    }
    sendRequest(e) {
        const t = {
            t: "d",
            d: e
        };
        this.sendData_(t);
    }
    tryCleanupConnection() {
        this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_ && (this.log_("cleaning up and promoting a connection: " + this.secondaryConn_.connId), this.conn_ = this.secondaryConn_, this.secondaryConn_ = null);
    }
    onSecondaryControl_(e) {
        if ("t" in e) {
            const t = e.t;
            "a" === t ? this.upgradeIfSecondaryHealthy_() : "r" === t ? (this.log_("Got a reset on secondary, closing it"), this.secondaryConn_.close(), this.tx_ !== this.secondaryConn_ && this.rx_ !== this.secondaryConn_ || this.close()) : "o" === t && (this.log_("got pong on secondary."), this.secondaryResponsesRequired_--, this.upgradeIfSecondaryHealthy_());
        }
    }
    onSecondaryMessageReceived_(e) {
        const t = ue("t", e), n = ue("d", e);
        if ("c" === t) this.onSecondaryControl_(n);
        else {
            if ("d" !== t) throw new Error("Unknown protocol layer: " + t);
            this.pendingDataMessages.push(n);
        }
    }
    upgradeIfSecondaryHealthy_() {
        this.secondaryResponsesRequired_ <= 0 ? (this.log_("Secondary connection is healthy."), this.isHealthy_ = !0, this.secondaryConn_.markConnectionHealthy(), this.proceedWithUpgrade_()) : (this.log_("sending ping on secondary."), this.secondaryConn_.send({
            t: "c",
            d: {
                t: "p",
                d: {}
            }
        }));
    }
    proceedWithUpgrade_() {
        this.secondaryConn_.start(), this.log_("sending client ack on secondary"), this.secondaryConn_.send({
            t: "c",
            d: {
                t: "a",
                d: {}
            }
        }), this.log_("Ending transmission on primary"), this.conn_.send({
            t: "c",
            d: {
                t: "n",
                d: {}
            }
        }), this.tx_ = this.secondaryConn_, this.tryCleanupConnection();
    }
    onPrimaryMessageReceived_(e) {
        const t = ue("t", e), n = ue("d", e);
        "c" === t ? this.onControl_(n) : "d" === t && this.onDataMessage_(n);
    }
    onDataMessage_(e) {
        this.onPrimaryResponse_(), this.onMessage_(e);
    }
    onPrimaryResponse_() {
        this.isHealthy_ || (this.primaryResponsesRequired_--, this.primaryResponsesRequired_ <= 0 && (this.log_("Primary connection is healthy."), this.isHealthy_ = !0, this.conn_.markConnectionHealthy()));
    }
    onControl_(e) {
        const t = ue("t", e);
        if ("d" in e) {
            const n = e.d;
            if ("h" === t) {
                const e = Object.assign({}, n);
                this.repoInfo_.isUsingEmulator && (e.h = this.repoInfo_.host), this.onHandshake_(e);
            } else if ("n" === t) {
                this.log_("recvd end transmission on primary"), this.rx_ = this.secondaryConn_;
                for(let e = 0; e < this.pendingDataMessages.length; ++e)this.onDataMessage_(this.pendingDataMessages[e]);
                this.pendingDataMessages = [], this.tryCleanupConnection();
            } else "s" === t ? this.onConnectionShutdown_(n) : "r" === t ? this.onReset_(n) : "e" === t ? ie("Server Error: " + n) : "o" === t ? (this.log_("got pong on primary."), this.onPrimaryResponse_(), this.sendPingOnPrimaryIfNecessary_()) : ie("Unknown control packet command: " + t);
        }
    }
    onHandshake_(e) {
        const t = e.ts, n = e.v, i = e.h;
        this.sessionId = e.s, this.repoInfo_.host = i, 0 === this.state_ && (this.conn_.start(), this.onConnectionEstablished_(this.conn_, t), "5" !== n && re("Protocol version mismatch detected"), this.tryStartUpgrade_());
    }
    tryStartUpgrade_() {
        const e = this.transportManager_.upgradeTransport();
        e && this.startUpgrade_(e);
    }
    startUpgrade_(e) {
        this.secondaryConn_ = new e(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId), this.secondaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0;
        const t = this.connReceiver_(this.secondaryConn_), n = this.disconnReceiver_(this.secondaryConn_);
        this.secondaryConn_.open(t, n), ve(()=>{
            this.secondaryConn_ && (this.log_("Timed out trying to upgrade."), this.secondaryConn_.close());
        }, Math.floor(6e4));
    }
    onReset_(e) {
        this.log_("Reset packet received.  New host: " + e), this.repoInfo_.host = e, 1 === this.state_ ? this.close() : (this.closeConnections_(), this.start_());
    }
    onConnectionEstablished_(e, t) {
        this.log_("Realtime connection established."), this.conn_ = e, this.state_ = 1, this.onReady_ && (this.onReady_(t, this.sessionId), this.onReady_ = null), 0 === this.primaryResponsesRequired_ ? (this.log_("Primary connection is healthy."), this.isHealthy_ = !0) : ve(()=>{
            this.sendPingOnPrimaryIfNecessary_();
        }, Math.floor(5e3));
    }
    sendPingOnPrimaryIfNecessary_() {
        this.isHealthy_ || 1 !== this.state_ || (this.log_("sending ping on primary."), this.sendData_({
            t: "c",
            d: {
                t: "p",
                d: {}
            }
        }));
    }
    onSecondaryConnectionLost_() {
        const e = this.secondaryConn_;
        this.secondaryConn_ = null, this.tx_ !== e && this.rx_ !== e || this.close();
    }
    onConnectionLost_(e) {
        this.conn_ = null, e || 0 !== this.state_ ? 1 === this.state_ && this.log_("Realtime connection lost.") : (this.log_("Realtime connection failed."), this.repoInfo_.isCacheableHost() && (Y.remove("host:" + this.repoInfo_.host), this.repoInfo_.internalHost = this.repoInfo_.host)), this.close();
    }
    onConnectionShutdown_(e) {
        this.log_("Connection shutdown command received. Shutting down..."), this.onKill_ && (this.onKill_(e), this.onKill_ = null), this.onDisconnect_ = null, this.close();
    }
    sendData_(e) {
        if (1 !== this.state_) throw "Connection is not connected";
        this.tx_.send(e);
    }
    close() {
        2 !== this.state_ && (this.log_("Closing realtime connection."), this.state_ = 2, this.closeConnections_(), this.onDisconnect_ && (this.onDisconnect_(), this.onDisconnect_ = null));
    }
    closeConnections_() {
        this.log_("Shutting down all connections"), this.conn_ && (this.conn_.close(), this.conn_ = null), this.secondaryConn_ && (this.secondaryConn_.close(), this.secondaryConn_ = null), this.healthyTimeout_ && (clearTimeout(this.healthyTimeout_), this.healthyTimeout_ = null);
    }
}
class Me {
    put(e, t, n, i) {}
    merge(e, t, n, i) {}
    refreshAuthToken(e) {}
    refreshAppCheckToken(e) {}
    onDisconnectPut(e, t, n) {}
    onDisconnectMerge(e, t, n) {}
    onDisconnectCancel(e, t) {}
    reportStats(e) {}
}
class qe {
    constructor(e){
        this.allowedEvents_ = e, this.listeners_ = {}, a(Array.isArray(e) && e.length > 0, "Requires a non-empty array");
    }
    trigger(e, ...t) {
        if (Array.isArray(this.listeners_[e])) {
            const n = [
                ...this.listeners_[e]
            ];
            for(let e = 0; e < n.length; e++)n[e].callback.apply(n[e].context, t);
        }
    }
    on(e, t, n) {
        this.validateEventType_(e), this.listeners_[e] = this.listeners_[e] || [], this.listeners_[e].push({
            callback: t,
            context: n
        });
        const i = this.getInitialEvent(e);
        i && t.apply(n, i);
    }
    off(e, t, n) {
        this.validateEventType_(e);
        const i = this.listeners_[e] || [];
        for(let e = 0; e < i.length; e++)if (i[e].callback === t && (!n || n === i[e].context)) return void i.splice(e, 1);
    }
    validateEventType_(e) {
        a(this.allowedEvents_.find((t)=>t === e), "Unknown event: " + e);
    }
}
class We extends qe {
    constructor(){
        super([
            "online"
        ]), this.online_ = !0, "undefined" == typeof window || void 0 === window.addEventListener || w() || (window.addEventListener("online", ()=>{
            this.online_ || (this.online_ = !0, this.trigger("online", !0));
        }, !1), window.addEventListener("offline", ()=>{
            this.online_ && (this.online_ = !1, this.trigger("online", !1));
        }, !1));
    }
    static getInstance() {
        return new We;
    }
    getInitialEvent(e) {
        return a("online" === e, "Unknown event type: " + e), [
            this.online_
        ];
    }
    currentlyOnline() {
        return this.online_;
    }
}
class Ue {
    constructor(e, t){
        if (void 0 === t) {
            this.pieces_ = e.split("/");
            let t = 0;
            for(let e = 0; e < this.pieces_.length; e++)this.pieces_[e].length > 0 && (this.pieces_[t] = this.pieces_[e], t++);
            this.pieces_.length = t, this.pieceNum_ = 0;
        } else this.pieces_ = e, this.pieceNum_ = t;
    }
    toString() {
        let e = "";
        for(let t = this.pieceNum_; t < this.pieces_.length; t++)"" !== this.pieces_[t] && (e += "/" + this.pieces_[t]);
        return e || "/";
    }
}
function Be() {
    return new Ue("");
}
function je(e) {
    return e.pieceNum_ >= e.pieces_.length ? null : e.pieces_[e.pieceNum_];
}
function He(e) {
    return e.pieces_.length - e.pieceNum_;
}
function Ve(e) {
    let t = e.pieceNum_;
    return t < e.pieces_.length && t++, new Ue(e.pieces_, t);
}
function ze(e) {
    return e.pieceNum_ < e.pieces_.length ? e.pieces_[e.pieces_.length - 1] : null;
}
function Ye(e, t = 0) {
    return e.pieces_.slice(e.pieceNum_ + t);
}
function Ke(e) {
    if (e.pieceNum_ >= e.pieces_.length) return null;
    const t = [];
    for(let n = e.pieceNum_; n < e.pieces_.length - 1; n++)t.push(e.pieces_[n]);
    return new Ue(t, 0);
}
function Qe(e, t) {
    const n = [];
    for(let t = e.pieceNum_; t < e.pieces_.length; t++)n.push(e.pieces_[t]);
    if (t instanceof Ue) for(let e = t.pieceNum_; e < t.pieces_.length; e++)n.push(t.pieces_[e]);
    else {
        const e = t.split("/");
        for(let t = 0; t < e.length; t++)e[t].length > 0 && n.push(e[t]);
    }
    return new Ue(n, 0);
}
function $e(e) {
    return e.pieceNum_ >= e.pieces_.length;
}
function Ge(e, t) {
    const n = je(e), i = je(t);
    if (null === n) return t;
    if (n === i) return Ge(Ve(e), Ve(t));
    throw new Error("INTERNAL ERROR: innerPath (" + t + ") is not within outerPath (" + e + ")");
}
function Je(e, t) {
    const n = Ye(e, 0), i = Ye(t, 0);
    for(let e = 0; e < n.length && e < i.length; e++){
        const t = he(n[e], i[e]);
        if (0 !== t) return t;
    }
    return n.length === i.length ? 0 : n.length < i.length ? -1 : 1;
}
function Xe(e, t) {
    if (He(e) !== He(t)) return !1;
    for(let n = e.pieceNum_, i = t.pieceNum_; n <= e.pieces_.length; n++, i++)if (e.pieces_[n] !== t.pieces_[i]) return !1;
    return !0;
}
function Ze(e, t) {
    let n = e.pieceNum_, i = t.pieceNum_;
    if (He(e) > He(t)) return !1;
    for(; n < e.pieces_.length;){
        if (e.pieces_[n] !== t.pieces_[i]) return !1;
        ++n, ++i;
    }
    return !0;
}
class et {
    constructor(e, t){
        this.errorPrefix_ = t, this.parts_ = Ye(e, 0), this.byteLength_ = Math.max(1, this.parts_.length);
        for(let e = 0; e < this.parts_.length; e++)this.byteLength_ += D(this.parts_[e]);
        tt(this);
    }
}
function tt(e) {
    if (e.byteLength_ > 768) throw new Error(e.errorPrefix_ + "has a key path longer than 768 bytes (" + e.byteLength_ + ").");
    if (e.parts_.length > 32) throw new Error(e.errorPrefix_ + "path specified exceeds the maximum depth that can be written (32) or object contains a cycle " + nt(e));
}
function nt(e) {
    return 0 === e.parts_.length ? "" : "in property '" + e.parts_.join(".") + "'";
}
class it extends qe {
    constructor(){
        let e, t;
        super([
            "visible"
        ]), "undefined" != typeof document && void 0 !== document.addEventListener && (void 0 !== document.hidden ? (t = "visibilitychange", e = "hidden") : void 0 !== document.mozHidden ? (t = "mozvisibilitychange", e = "mozHidden") : void 0 !== document.msHidden ? (t = "msvisibilitychange", e = "msHidden") : void 0 !== document.webkitHidden && (t = "webkitvisibilitychange", e = "webkitHidden")), this.visible_ = !0, t && document.addEventListener(t, ()=>{
            const t = !document[e];
            t !== this.visible_ && (this.visible_ = t, this.trigger("visible", t));
        }, !1);
    }
    static getInstance() {
        return new it;
    }
    getInitialEvent(e) {
        return a("visible" === e, "Unknown event type: " + e), [
            this.visible_
        ];
    }
}
class st extends Me {
    constructor(e, t, n, i, s, r, o, a){
        if (super(), this.repoInfo_ = e, this.applicationId_ = t, this.onDataUpdate_ = n, this.onConnectStatus_ = i, this.onServerInfoUpdate_ = s, this.authTokenProvider_ = r, this.appCheckTokenProvider_ = o, this.authOverride_ = a, this.id = st.nextPersistentConnectionId_++, this.log_ = ne("p:" + this.id + ":"), this.interruptReasons_ = {}, this.listens = new Map, this.outstandingPuts_ = [], this.outstandingGets_ = [], this.outstandingPutCount_ = 0, this.outstandingGetCount_ = 0, this.onDisconnectRequestQueue_ = [], this.connected_ = !1, this.reconnectDelay_ = 1e3, this.maxReconnectDelay_ = 3e5, this.securityDebugCallback_ = null, this.lastSessionId = null, this.establishConnectionTimer_ = null, this.visible_ = !1, this.requestCBHash_ = {}, this.requestNumber_ = 0, this.realtime_ = null, this.authToken_ = null, this.appCheckToken_ = null, this.forceTokenRefresh_ = !1, this.invalidAuthTokenCount_ = 0, this.invalidAppCheckTokenCount_ = 0, this.firstConnection_ = !0, this.lastConnectionAttemptTime_ = null, this.lastConnectionEstablishedTime_ = null, a && !T()) throw new Error("Auth override specified in options, but not supported on non Node.js platforms");
        it.getInstance().on("visible", this.onVisible_, this), -1 === e.host.indexOf("fblocal") && We.getInstance().on("online", this.onOnline_, this);
    }
    sendRequest(e, t, n) {
        const i = ++this.requestNumber_, s = {
            r: i,
            a: e,
            b: t
        };
        this.log_(E(s)), a(this.connected_, "sendRequest call when we're not connected not allowed."), this.realtime_.sendRequest(s), n && (this.requestCBHash_[i] = n);
    }
    get(e) {
        this.initConnection_();
        const t = new C, n = {
            action: "g",
            request: {
                p: e._path.toString(),
                q: e._queryObject
            },
            onComplete: (e)=>{
                const n = e.d;
                "ok" === e.s ? t.resolve(n) : t.reject(n);
            }
        };
        this.outstandingGets_.push(n), this.outstandingGetCount_++;
        const i = this.outstandingGets_.length - 1;
        return this.connected_ && this.sendGet_(i), t.promise;
    }
    listen(e, t, n, i) {
        this.initConnection_();
        const s = e._queryIdentifier, r = e._path.toString();
        this.log_("Listen called for " + r + " " + s), this.listens.has(r) || this.listens.set(r, new Map), a(e._queryParams.isDefault() || !e._queryParams.loadsAllData(), "listen() called for non-default but complete query"), a(!this.listens.get(r).has(s), "listen() called twice for same path/queryId.");
        const o = {
            onComplete: i,
            hashFn: t,
            query: e,
            tag: n
        };
        this.listens.get(r).set(s, o), this.connected_ && this.sendListen_(o);
    }
    sendGet_(e) {
        const t = this.outstandingGets_[e];
        this.sendRequest("g", t.request, (n)=>{
            delete this.outstandingGets_[e], this.outstandingGetCount_--, 0 === this.outstandingGetCount_ && (this.outstandingGets_ = []), t.onComplete && t.onComplete(n);
        });
    }
    sendListen_(e) {
        const t = e.query, n = t._path.toString(), i = t._queryIdentifier;
        this.log_("Listen on " + n + " for " + i);
        const s = {
            p: n
        };
        e.tag && (s.q = t._queryObject, s.t = e.tag), s.h = e.hashFn(), this.sendRequest("q", s, (s)=>{
            const r = s.d, o = s.s;
            st.warnOnListenWarnings_(r, t);
            (this.listens.get(n) && this.listens.get(n).get(i)) === e && (this.log_("listen response", s), "ok" !== o && this.removeListen_(n, i), e.onComplete && e.onComplete(o, r));
        });
    }
    static warnOnListenWarnings_(e, t) {
        if (e && "object" == typeof e && S(e, "w")) {
            const n = k(e, "w");
            if (Array.isArray(n) && ~n.indexOf("no_index")) {
                const e = '".indexOn": "' + t._queryParams.getIndex().toString() + '"', n = t._path.toString();
                re(`Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${e} at ${n} to your security rules for better performance.`);
            }
        }
    }
    refreshAuthToken(e) {
        this.authToken_ = e, this.log_("Auth token refreshed"), this.authToken_ ? this.tryAuth() : this.connected_ && this.sendRequest("unauth", {}, ()=>{}), this.reduceReconnectDelayIfAdminCredential_(e);
    }
    reduceReconnectDelayIfAdminCredential_(e) {
        (e && 40 === e.length || function(e) {
            const t = I(e).claims;
            return "object" == typeof t && !0 === t.admin;
        }(e)) && (this.log_("Admin auth credential detected.  Reducing max reconnect time."), this.maxReconnectDelay_ = 3e4);
    }
    refreshAppCheckToken(e) {
        this.appCheckToken_ = e, this.log_("App check token refreshed"), this.appCheckToken_ ? this.tryAppCheck() : this.connected_ && this.sendRequest("unappeck", {}, ()=>{});
    }
    tryAuth() {
        if (this.connected_ && this.authToken_) {
            const e = this.authToken_, t = function(e) {
                const t = I(e).claims;
                return !!t && "object" == typeof t && t.hasOwnProperty("iat");
            }(e) ? "auth" : "gauth", n = {
                cred: e
            };
            null === this.authOverride_ ? n.noauth = !0 : "object" == typeof this.authOverride_ && (n.authvar = this.authOverride_), this.sendRequest(t, n, (t)=>{
                const n = t.s, i = t.d || "error";
                this.authToken_ === e && ("ok" === n ? this.invalidAuthTokenCount_ = 0 : this.onAuthRevoked_(n, i));
            });
        }
    }
    tryAppCheck() {
        this.connected_ && this.appCheckToken_ && this.sendRequest("appcheck", {
            token: this.appCheckToken_
        }, (e)=>{
            const t = e.s, n = e.d || "error";
            "ok" === t ? this.invalidAppCheckTokenCount_ = 0 : this.onAppCheckRevoked_(t, n);
        });
    }
    unlisten(e, t) {
        const n = e._path.toString(), i = e._queryIdentifier;
        this.log_("Unlisten called for " + n + " " + i), a(e._queryParams.isDefault() || !e._queryParams.loadsAllData(), "unlisten() called for non-default but complete query");
        this.removeListen_(n, i) && this.connected_ && this.sendUnlisten_(n, i, e._queryObject, t);
    }
    sendUnlisten_(e, t, n, i) {
        this.log_("Unlisten on " + e + " for " + t);
        const s = {
            p: e
        };
        i && (s.q = n, s.t = i), this.sendRequest("n", s);
    }
    onDisconnectPut(e, t, n) {
        this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("o", e, t, n) : this.onDisconnectRequestQueue_.push({
            pathString: e,
            action: "o",
            data: t,
            onComplete: n
        });
    }
    onDisconnectMerge(e, t, n) {
        this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("om", e, t, n) : this.onDisconnectRequestQueue_.push({
            pathString: e,
            action: "om",
            data: t,
            onComplete: n
        });
    }
    onDisconnectCancel(e, t) {
        this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("oc", e, null, t) : this.onDisconnectRequestQueue_.push({
            pathString: e,
            action: "oc",
            data: null,
            onComplete: t
        });
    }
    sendOnDisconnect_(e, t, n, i) {
        const s = {
            p: t,
            d: n
        };
        this.log_("onDisconnect " + e, s), this.sendRequest(e, s, (e)=>{
            i && setTimeout(()=>{
                i(e.s, e.d);
            }, Math.floor(0));
        });
    }
    put(e, t, n, i) {
        this.putInternal("p", e, t, n, i);
    }
    merge(e, t, n, i) {
        this.putInternal("m", e, t, n, i);
    }
    putInternal(e, t, n, i, s) {
        this.initConnection_();
        const r = {
            p: t,
            d: n
        };
        void 0 !== s && (r.h = s), this.outstandingPuts_.push({
            action: e,
            request: r,
            onComplete: i
        }), this.outstandingPutCount_++;
        const o = this.outstandingPuts_.length - 1;
        this.connected_ ? this.sendPut_(o) : this.log_("Buffering put: " + t);
    }
    sendPut_(e) {
        const t = this.outstandingPuts_[e].action, n = this.outstandingPuts_[e].request, i = this.outstandingPuts_[e].onComplete;
        this.outstandingPuts_[e].queued = this.connected_, this.sendRequest(t, n, (n)=>{
            this.log_(t + " response", n), delete this.outstandingPuts_[e], this.outstandingPutCount_--, 0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []), i && i(n.s, n.d);
        });
    }
    reportStats(e) {
        if (this.connected_) {
            const t = {
                c: e
            };
            this.log_("reportStats", t), this.sendRequest("s", t, (e)=>{
                if ("ok" !== e.s) {
                    const t = e.d;
                    this.log_("reportStats", "Error sending stats: " + t);
                }
            });
        }
    }
    onDataMessage_(e) {
        if ("r" in e) {
            this.log_("from server: " + E(e));
            const t = e.r, n = this.requestCBHash_[t];
            n && (delete this.requestCBHash_[t], n(e.b));
        } else {
            if ("error" in e) throw "A server-side error has occurred: " + e.error;
            "a" in e && this.onDataPush_(e.a, e.b);
        }
    }
    onDataPush_(e, t) {
        this.log_("handleServerMessage", e, t), "d" === e ? this.onDataUpdate_(t.p, t.d, !1, t.t) : "m" === e ? this.onDataUpdate_(t.p, t.d, !0, t.t) : "c" === e ? this.onListenRevoked_(t.p, t.q) : "ac" === e ? this.onAuthRevoked_(t.s, t.d) : "apc" === e ? this.onAppCheckRevoked_(t.s, t.d) : "sd" === e ? this.onSecurityDebugPacket_(t) : ie("Unrecognized action received from server: " + E(e) + "\nAre you using the latest client?");
    }
    onReady_(e, t) {
        this.log_("connection ready"), this.connected_ = !0, this.lastConnectionEstablishedTime_ = (new Date).getTime(), this.handleTimestamp_(e), this.lastSessionId = t, this.firstConnection_ && this.sendConnectStats_(), this.restoreState_(), this.firstConnection_ = !1, this.onConnectStatus_(!0);
    }
    scheduleConnect_(e) {
        a(!this.realtime_, "Scheduling a connect when we're already connected/ing?"), this.establishConnectionTimer_ && clearTimeout(this.establishConnectionTimer_), this.establishConnectionTimer_ = setTimeout(()=>{
            this.establishConnectionTimer_ = null, this.establishConnection_();
        }, Math.floor(e));
    }
    initConnection_() {
        !this.realtime_ && this.firstConnection_ && this.scheduleConnect_(0);
    }
    onVisible_(e) {
        e && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_ && (this.log_("Window became visible.  Reducing delay."), this.reconnectDelay_ = 1e3, this.realtime_ || this.scheduleConnect_(0)), this.visible_ = e;
    }
    onOnline_(e) {
        e ? (this.log_("Browser went online."), this.reconnectDelay_ = 1e3, this.realtime_ || this.scheduleConnect_(0)) : (this.log_("Browser went offline.  Killing connection."), this.realtime_ && this.realtime_.close());
    }
    onRealtimeDisconnect_() {
        if (this.log_("data client disconnected"), this.connected_ = !1, this.realtime_ = null, this.cancelSentTransactions_(), this.requestCBHash_ = {}, this.shouldReconnect_()) {
            if (this.visible_) {
                if (this.lastConnectionEstablishedTime_) (new Date).getTime() - this.lastConnectionEstablishedTime_ > 3e4 && (this.reconnectDelay_ = 1e3), this.lastConnectionEstablishedTime_ = null;
            } else this.log_("Window isn't visible.  Delaying reconnect."), this.reconnectDelay_ = this.maxReconnectDelay_, this.lastConnectionAttemptTime_ = (new Date).getTime();
            const e = (new Date).getTime() - this.lastConnectionAttemptTime_;
            let t = Math.max(0, this.reconnectDelay_ - e);
            t = Math.random() * t, this.log_("Trying to reconnect in " + t + "ms"), this.scheduleConnect_(t), this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, 1.3 * this.reconnectDelay_);
        }
        this.onConnectStatus_(!1);
    }
    async establishConnection_() {
        if (this.shouldReconnect_()) {
            this.log_("Making a connection attempt"), this.lastConnectionAttemptTime_ = (new Date).getTime(), this.lastConnectionEstablishedTime_ = null;
            const e = this.onDataMessage_.bind(this), t = this.onReady_.bind(this), n = this.onRealtimeDisconnect_.bind(this), i = this.id + ":" + st.nextConnectionId_++, s = this.lastSessionId;
            let r = !1, o = null;
            const l = function() {
                o ? o.close() : (r = !0, n());
            }, h = function(e) {
                a(o, "sendRequest call when we're not connected not allowed."), o.sendRequest(e);
            };
            this.realtime_ = {
                close: l,
                sendRequest: h
            };
            const c = this.forceTokenRefresh_;
            this.forceTokenRefresh_ = !1;
            try {
                const [a, l] = await Promise.all([
                    this.authTokenProvider_.getToken(c),
                    this.appCheckTokenProvider_.getToken(c)
                ]);
                r ? te("getToken() completed but was canceled") : (te("getToken() completed. Creating connection."), this.authToken_ = a && a.accessToken, this.appCheckToken_ = l && l.token, o = new Fe(i, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, e, t, n, (e)=>{
                    re(e + " (" + this.repoInfo_.toString() + ")"), this.interrupt("server_kill");
                }, s));
            } catch (e) {
                this.log_("Failed to get token: " + e), r || (this.repoInfo_.nodeAdmin && re(e), l());
            }
        }
    }
    interrupt(e) {
        te("Interrupting connection for reason: " + e), this.interruptReasons_[e] = !0, this.realtime_ ? this.realtime_.close() : (this.establishConnectionTimer_ && (clearTimeout(this.establishConnectionTimer_), this.establishConnectionTimer_ = null), this.connected_ && this.onRealtimeDisconnect_());
    }
    resume(e) {
        te("Resuming connection for reason: " + e), delete this.interruptReasons_[e], N(this.interruptReasons_) && (this.reconnectDelay_ = 1e3, this.realtime_ || this.scheduleConnect_(0));
    }
    handleTimestamp_(e) {
        const t = e - (new Date).getTime();
        this.onServerInfoUpdate_({
            serverTimeOffset: t
        });
    }
    cancelSentTransactions_() {
        for(let e = 0; e < this.outstandingPuts_.length; e++){
            const t = this.outstandingPuts_[e];
            t && "h" in t.request && t.queued && (t.onComplete && t.onComplete("disconnect"), delete this.outstandingPuts_[e], this.outstandingPutCount_--);
        }
        0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []);
    }
    onListenRevoked_(e, t) {
        let n;
        n = t ? t.map((e)=>de(e)).join("$") : "default";
        const i = this.removeListen_(e, n);
        i && i.onComplete && i.onComplete("permission_denied");
    }
    removeListen_(e, t) {
        const n = new Ue(e).toString();
        let i;
        if (this.listens.has(n)) {
            const e = this.listens.get(n);
            i = e.get(t), e.delete(t), 0 === e.size && this.listens.delete(n);
        } else i = void 0;
        return i;
    }
    onAuthRevoked_(e, t) {
        te("Auth token revoked: " + e + "/" + t), this.authToken_ = null, this.forceTokenRefresh_ = !0, this.realtime_.close(), "invalid_token" !== e && "permission_denied" !== e || (this.invalidAuthTokenCount_++, this.invalidAuthTokenCount_ >= 3 && (this.reconnectDelay_ = 3e4, this.authTokenProvider_.notifyForInvalidToken()));
    }
    onAppCheckRevoked_(e, t) {
        te("App check token revoked: " + e + "/" + t), this.appCheckToken_ = null, this.forceTokenRefresh_ = !0, "invalid_token" !== e && "permission_denied" !== e || (this.invalidAppCheckTokenCount_++, this.invalidAppCheckTokenCount_ >= 3 && this.appCheckTokenProvider_.notifyForInvalidToken());
    }
    onSecurityDebugPacket_(e) {
        this.securityDebugCallback_ ? this.securityDebugCallback_(e) : "msg" in e && console.log("FIREBASE: " + e.msg.replace("\n", "\nFIREBASE: "));
    }
    restoreState_() {
        this.tryAuth(), this.tryAppCheck();
        for (const e of this.listens.values())for (const t of e.values())this.sendListen_(t);
        for(let e = 0; e < this.outstandingPuts_.length; e++)this.outstandingPuts_[e] && this.sendPut_(e);
        for(; this.onDisconnectRequestQueue_.length;){
            const e = this.onDisconnectRequestQueue_.shift();
            this.sendOnDisconnect_(e.action, e.pathString, e.data, e.onComplete);
        }
        for(let e = 0; e < this.outstandingGets_.length; e++)this.outstandingGets_[e] && this.sendGet_(e);
    }
    sendConnectStats_() {
        const e = {};
        e["sdk.js." + B.replace(/\./g, "-")] = 1, w() ? e["framework.cordova"] = 1 : "object" == typeof navigator && "ReactNative" === navigator.product && (e["framework.reactnative"] = 1), this.reportStats(e);
    }
    shouldReconnect_() {
        const e = We.getInstance().currentlyOnline();
        return N(this.interruptReasons_) && e;
    }
}
st.nextPersistentConnectionId_ = 0, st.nextConnectionId_ = 0;
class rt {
    constructor(e, t){
        this.name = e, this.node = t;
    }
    static Wrap(e, t) {
        return new rt(e, t);
    }
}
class ot {
    getCompare() {
        return this.compare.bind(this);
    }
    indexedValueChanged(e, t) {
        const n = new rt(ae, e), i = new rt(ae, t);
        return 0 !== this.compare(n, i);
    }
    minPost() {
        return rt.MIN;
    }
}
let at;
class lt extends ot {
    static get __EMPTY_NODE() {
        return at;
    }
    static set __EMPTY_NODE(e) {
        at = e;
    }
    compare(e, t) {
        return he(e.name, t.name);
    }
    isDefinedOn(e) {
        throw l("KeyIndex.isDefinedOn not expected to be called.");
    }
    indexedValueChanged(e, t) {
        return !1;
    }
    minPost() {
        return rt.MIN;
    }
    maxPost() {
        return new rt(le, at);
    }
    makePost(e, t) {
        return a("string" == typeof e, "KeyIndex indexValue must always be a string."), new rt(e, at);
    }
    toString() {
        return ".key";
    }
}
const ht = new lt;
class ct {
    constructor(e, t, n, i, s = null){
        this.isReverse_ = i, this.resultGenerator_ = s, this.nodeStack_ = [];
        let r = 1;
        for(; !e.isEmpty();)if (e, r = t ? n(e.key, t) : 1, i && (r *= -1), r < 0) e = this.isReverse_ ? e.left : e.right;
        else {
            if (0 === r) {
                this.nodeStack_.push(e);
                break;
            }
            this.nodeStack_.push(e), e = this.isReverse_ ? e.right : e.left;
        }
    }
    getNext() {
        if (0 === this.nodeStack_.length) return null;
        let e, t = this.nodeStack_.pop();
        if (e = this.resultGenerator_ ? this.resultGenerator_(t.key, t.value) : {
            key: t.key,
            value: t.value
        }, this.isReverse_) for(t = t.left; !t.isEmpty();)this.nodeStack_.push(t), t = t.right;
        else for(t = t.right; !t.isEmpty();)this.nodeStack_.push(t), t = t.left;
        return e;
    }
    hasNext() {
        return this.nodeStack_.length > 0;
    }
    peek() {
        if (0 === this.nodeStack_.length) return null;
        const e = this.nodeStack_[this.nodeStack_.length - 1];
        return this.resultGenerator_ ? this.resultGenerator_(e.key, e.value) : {
            key: e.key,
            value: e.value
        };
    }
}
class ut {
    constructor(e, t, n, i, s){
        this.key = e, this.value = t, this.color = null != n ? n : ut.RED, this.left = null != i ? i : dt.EMPTY_NODE, this.right = null != s ? s : dt.EMPTY_NODE;
    }
    copy(e, t, n, i, s) {
        return new ut(null != e ? e : this.key, null != t ? t : this.value, null != n ? n : this.color, null != i ? i : this.left, null != s ? s : this.right);
    }
    count() {
        return this.left.count() + 1 + this.right.count();
    }
    isEmpty() {
        return !1;
    }
    inorderTraversal(e) {
        return this.left.inorderTraversal(e) || !!e(this.key, this.value) || this.right.inorderTraversal(e);
    }
    reverseTraversal(e) {
        return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e);
    }
    min_() {
        return this.left.isEmpty() ? this : this.left.min_();
    }
    minKey() {
        return this.min_().key;
    }
    maxKey() {
        return this.right.isEmpty() ? this.key : this.right.maxKey();
    }
    insert(e, t, n) {
        let i = this;
        const s = n(e, i.key);
        return i = s < 0 ? i.copy(null, null, null, i.left.insert(e, t, n), null) : 0 === s ? i.copy(null, t, null, null, null) : i.copy(null, null, null, null, i.right.insert(e, t, n)), i.fixUp_();
    }
    removeMin_() {
        if (this.left.isEmpty()) return dt.EMPTY_NODE;
        let e = this;
        return e.left.isRed_() || e.left.left.isRed_() || (e = e.moveRedLeft_()), e = e.copy(null, null, null, e.left.removeMin_(), null), e.fixUp_();
    }
    remove(e, t) {
        let n, i;
        if (n = this, t(e, n.key) < 0) n.left.isEmpty() || n.left.isRed_() || n.left.left.isRed_() || (n = n.moveRedLeft_()), n = n.copy(null, null, null, n.left.remove(e, t), null);
        else {
            if (n.left.isRed_() && (n = n.rotateRight_()), n.right.isEmpty() || n.right.isRed_() || n.right.left.isRed_() || (n = n.moveRedRight_()), 0 === t(e, n.key)) {
                if (n.right.isEmpty()) return dt.EMPTY_NODE;
                i = n.right.min_(), n = n.copy(i.key, i.value, null, null, n.right.removeMin_());
            }
            n = n.copy(null, null, null, null, n.right.remove(e, t));
        }
        return n.fixUp_();
    }
    isRed_() {
        return this.color;
    }
    fixUp_() {
        let e = this;
        return e.right.isRed_() && !e.left.isRed_() && (e = e.rotateLeft_()), e.left.isRed_() && e.left.left.isRed_() && (e = e.rotateRight_()), e.left.isRed_() && e.right.isRed_() && (e = e.colorFlip_()), e;
    }
    moveRedLeft_() {
        let e = this.colorFlip_();
        return e.right.left.isRed_() && (e = e.copy(null, null, null, null, e.right.rotateRight_()), e = e.rotateLeft_(), e = e.colorFlip_()), e;
    }
    moveRedRight_() {
        let e = this.colorFlip_();
        return e.left.left.isRed_() && (e = e.rotateRight_(), e = e.colorFlip_()), e;
    }
    rotateLeft_() {
        const e = this.copy(null, null, ut.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, e, null);
    }
    rotateRight_() {
        const e = this.copy(null, null, ut.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, e);
    }
    colorFlip_() {
        const e = this.left.copy(null, null, !this.left.color, null, null), t = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, e, t);
    }
    checkMaxDepth_() {
        const e = this.check_();
        return Math.pow(2, e) <= this.count() + 1;
    }
    check_() {
        if (this.isRed_() && this.left.isRed_()) throw new Error("Red node has red child(" + this.key + "," + this.value + ")");
        if (this.right.isRed_()) throw new Error("Right child of (" + this.key + "," + this.value + ") is red");
        const e = this.left.check_();
        if (e !== this.right.check_()) throw new Error("Black depths differ");
        return e + (this.isRed_() ? 0 : 1);
    }
}
ut.RED = !0, ut.BLACK = !1;
class dt {
    constructor(e, t = dt.EMPTY_NODE){
        this.comparator_ = e, this.root_ = t;
    }
    insert(e, t) {
        return new dt(this.comparator_, this.root_.insert(e, t, this.comparator_).copy(null, null, ut.BLACK, null, null));
    }
    remove(e) {
        return new dt(this.comparator_, this.root_.remove(e, this.comparator_).copy(null, null, ut.BLACK, null, null));
    }
    get(e) {
        let t, n = this.root_;
        for(; !n.isEmpty();){
            if (t = this.comparator_(e, n.key), 0 === t) return n.value;
            t < 0 ? n = n.left : t > 0 && (n = n.right);
        }
        return null;
    }
    getPredecessorKey(e) {
        let t, n = this.root_, i = null;
        for(; !n.isEmpty();){
            if (t = this.comparator_(e, n.key), 0 === t) {
                if (n.left.isEmpty()) return i ? i.key : null;
                for(n = n.left; !n.right.isEmpty();)n = n.right;
                return n.key;
            }
            t < 0 ? n = n.left : t > 0 && (i = n, n = n.right);
        }
        throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?");
    }
    isEmpty() {
        return this.root_.isEmpty();
    }
    count() {
        return this.root_.count();
    }
    minKey() {
        return this.root_.minKey();
    }
    maxKey() {
        return this.root_.maxKey();
    }
    inorderTraversal(e) {
        return this.root_.inorderTraversal(e);
    }
    reverseTraversal(e) {
        return this.root_.reverseTraversal(e);
    }
    getIterator(e) {
        return new ct(this.root_, null, this.comparator_, !1, e);
    }
    getIteratorFrom(e, t) {
        return new ct(this.root_, e, this.comparator_, !1, t);
    }
    getReverseIteratorFrom(e, t) {
        return new ct(this.root_, e, this.comparator_, !0, t);
    }
    getReverseIterator(e) {
        return new ct(this.root_, null, this.comparator_, !0, e);
    }
}
function _t(e, t) {
    return he(e.name, t.name);
}
function pt(e, t) {
    return he(e, t);
}
let ft;
dt.EMPTY_NODE = new class {
    copy(e, t, n, i, s) {
        return this;
    }
    insert(e, t, n) {
        return new ut(e, t, null);
    }
    remove(e, t) {
        return this;
    }
    count() {
        return 0;
    }
    isEmpty() {
        return !0;
    }
    inorderTraversal(e) {
        return !1;
    }
    reverseTraversal(e) {
        return !1;
    }
    minKey() {
        return null;
    }
    maxKey() {
        return null;
    }
    check_() {
        return 0;
    }
    isRed_() {
        return !1;
    }
};
const gt = function(e) {
    return "number" == typeof e ? "number:" + fe(e) : "string:" + e;
}, mt = function(e) {
    if (e.isLeafNode()) {
        const t = e.val();
        a("string" == typeof t || "number" == typeof t || "object" == typeof t && S(t, ".sv"), "Priority must be a string or number.");
    } else a(e === ft || e.isEmpty(), "priority of unexpected type.");
    a(e === ft || e.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
};
let yt, vt, Ct;
class wt {
    constructor(e, t = wt.__childrenNodeConstructor.EMPTY_NODE){
        this.value_ = e, this.priorityNode_ = t, this.lazyHash_ = null, a(void 0 !== this.value_ && null !== this.value_, "LeafNode shouldn't be created with null/undefined value."), mt(this.priorityNode_);
    }
    static set __childrenNodeConstructor(e) {
        yt = e;
    }
    static get __childrenNodeConstructor() {
        return yt;
    }
    isLeafNode() {
        return !0;
    }
    getPriority() {
        return this.priorityNode_;
    }
    updatePriority(e) {
        return new wt(this.value_, e);
    }
    getImmediateChild(e) {
        return ".priority" === e ? this.priorityNode_ : wt.__childrenNodeConstructor.EMPTY_NODE;
    }
    getChild(e) {
        return $e(e) ? this : ".priority" === je(e) ? this.priorityNode_ : wt.__childrenNodeConstructor.EMPTY_NODE;
    }
    hasChild() {
        return !1;
    }
    getPredecessorChildName(e, t) {
        return null;
    }
    updateImmediateChild(e, t) {
        return ".priority" === e ? this.updatePriority(t) : t.isEmpty() && ".priority" !== e ? this : wt.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(e, t).updatePriority(this.priorityNode_);
    }
    updateChild(e, t) {
        const n = je(e);
        return null === n ? t : t.isEmpty() && ".priority" !== n ? this : (a(".priority" !== n || 1 === He(e), ".priority must be the last token in a path"), this.updateImmediateChild(n, wt.__childrenNodeConstructor.EMPTY_NODE.updateChild(Ve(e), t)));
    }
    isEmpty() {
        return !1;
    }
    numChildren() {
        return 0;
    }
    forEachChild(e, t) {
        return !1;
    }
    val(e) {
        return e && !this.getPriority().isEmpty() ? {
            ".value": this.getValue(),
            ".priority": this.getPriority().val()
        } : this.getValue();
    }
    hash() {
        if (null === this.lazyHash_) {
            let e = "";
            this.priorityNode_.isEmpty() || (e += "priority:" + gt(this.priorityNode_.val()) + ":");
            const t = typeof this.value_;
            e += t + ":", e += "number" === t ? fe(this.value_) : this.value_, this.lazyHash_ = G(e);
        }
        return this.lazyHash_;
    }
    getValue() {
        return this.value_;
    }
    compareTo(e) {
        return e === wt.__childrenNodeConstructor.EMPTY_NODE ? 1 : e instanceof wt.__childrenNodeConstructor ? -1 : (a(e.isLeafNode(), "Unknown node type"), this.compareToLeafNode_(e));
    }
    compareToLeafNode_(e) {
        const t = typeof e.value_, n = typeof this.value_, i = wt.VALUE_TYPE_ORDER.indexOf(t), s = wt.VALUE_TYPE_ORDER.indexOf(n);
        return a(i >= 0, "Unknown leaf type: " + t), a(s >= 0, "Unknown leaf type: " + n), i === s ? "object" === n ? 0 : this.value_ < e.value_ ? -1 : this.value_ === e.value_ ? 0 : 1 : s - i;
    }
    withIndex() {
        return this;
    }
    isIndexed() {
        return !0;
    }
    equals(e) {
        if (e === this) return !0;
        if (e.isLeafNode()) {
            const t = e;
            return this.value_ === t.value_ && this.priorityNode_.equals(t.priorityNode_);
        }
        return !1;
    }
}
wt.VALUE_TYPE_ORDER = [
    "object",
    "boolean",
    "number",
    "string"
];
const Tt = new class extends ot {
    compare(e, t) {
        const n = e.node.getPriority(), i = t.node.getPriority(), s = n.compareTo(i);
        return 0 === s ? he(e.name, t.name) : s;
    }
    isDefinedOn(e) {
        return !e.getPriority().isEmpty();
    }
    indexedValueChanged(e, t) {
        return !e.getPriority().equals(t.getPriority());
    }
    minPost() {
        return rt.MIN;
    }
    maxPost() {
        return new rt(le, new wt("[PRIORITY-POST]", Ct));
    }
    makePost(e, t) {
        const n = vt(e);
        return new rt(t, new wt("[PRIORITY-POST]", n));
    }
    toString() {
        return ".priority";
    }
}, bt = Math.log(2);
class Et {
    constructor(e){
        var t;
        this.count = (t = e + 1, parseInt(Math.log(t) / bt, 10)), this.current_ = this.count - 1;
        const n = (i = this.count, parseInt(Array(i + 1).join("1"), 2));
        var i;
        this.bits_ = e + 1 & n;
    }
    nextBitIsOne() {
        const e = !(this.bits_ & 1 << this.current_);
        return this.current_--, e;
    }
}
const It = function(e, t, n, i) {
    e.sort(t);
    const s = function(t, i) {
        const r = i - t;
        let o, a;
        if (0 === r) return null;
        if (1 === r) return o = e[t], a = n ? n(o) : o, new ut(a, o.node, ut.BLACK, null, null);
        {
            const l = parseInt(r / 2, 10) + t, h = s(t, l), c = s(l + 1, i);
            return o = e[l], a = n ? n(o) : o, new ut(a, o.node, ut.BLACK, h, c);
        }
    }, r = function(t) {
        let i = null, r = null, o = e.length;
        const a = function(t, i) {
            const r = o - t, a = o;
            o -= t;
            const h = s(r + 1, a), c = e[r], u = n ? n(c) : c;
            l(new ut(u, c.node, i, null, h));
        }, l = function(e) {
            i ? (i.left = e, i = e) : (r = e, i = e);
        };
        for(let e = 0; e < t.count; ++e){
            const n = t.nextBitIsOne(), i = Math.pow(2, t.count - (e + 1));
            n ? a(i, ut.BLACK) : (a(i, ut.BLACK), a(i, ut.RED));
        }
        return r;
    }(new Et(e.length));
    return new dt(i || t, r);
};
let St;
const kt = {};
class Nt {
    constructor(e, t){
        this.indexes_ = e, this.indexSet_ = t;
    }
    static get Default() {
        return a(kt && Tt, "ChildrenNode.ts has not been loaded"), St = St || new Nt({
            ".priority": kt
        }, {
            ".priority": Tt
        }), St;
    }
    get(e) {
        const t = k(this.indexes_, e);
        if (!t) throw new Error("No index defined for " + e);
        return t instanceof dt ? t : null;
    }
    hasIndex(e) {
        return S(this.indexSet_, e.toString());
    }
    addIndex(e, t) {
        a(e !== ht, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        const n = [];
        let i = !1;
        const s = t.getIterator(rt.Wrap);
        let r, o = s.getNext();
        for(; o;)i = i || e.isDefinedOn(o.node), n.push(o), o = s.getNext();
        r = i ? It(n, e.getCompare()) : kt;
        const l = e.toString(), h = Object.assign({}, this.indexSet_);
        h[l] = e;
        const c = Object.assign({}, this.indexes_);
        return c[l] = r, new Nt(c, h);
    }
    addToIndexes(e, t) {
        const n = P(this.indexes_, (n, i)=>{
            const s = k(this.indexSet_, i);
            if (a(s, "Missing index implementation for " + i), n === kt) {
                if (s.isDefinedOn(e.node)) {
                    const n = [], i = t.getIterator(rt.Wrap);
                    let r = i.getNext();
                    for(; r;)r.name !== e.name && n.push(r), r = i.getNext();
                    return n.push(e), It(n, s.getCompare());
                }
                return kt;
            }
            {
                const i = t.get(e.name);
                let s = n;
                return i && (s = s.remove(new rt(e.name, i))), s.insert(e, e.node);
            }
        });
        return new Nt(n, this.indexSet_);
    }
    removeFromIndexes(e, t) {
        const n = P(this.indexes_, (n)=>{
            if (n === kt) return n;
            {
                const i = t.get(e.name);
                return i ? n.remove(new rt(e.name, i)) : n;
            }
        });
        return new Nt(n, this.indexSet_);
    }
}
let Pt;
class xt {
    constructor(e, t, n){
        this.children_ = e, this.priorityNode_ = t, this.indexMap_ = n, this.lazyHash_ = null, this.priorityNode_ && mt(this.priorityNode_), this.children_.isEmpty() && a(!this.priorityNode_ || this.priorityNode_.isEmpty(), "An empty node cannot have a priority");
    }
    static get EMPTY_NODE() {
        return Pt || (Pt = new xt(new dt(pt), null, Nt.Default));
    }
    isLeafNode() {
        return !1;
    }
    getPriority() {
        return this.priorityNode_ || Pt;
    }
    updatePriority(e) {
        return this.children_.isEmpty() ? this : new xt(this.children_, e, this.indexMap_);
    }
    getImmediateChild(e) {
        if (".priority" === e) return this.getPriority();
        {
            const t = this.children_.get(e);
            return null === t ? Pt : t;
        }
    }
    getChild(e) {
        const t = je(e);
        return null === t ? this : this.getImmediateChild(t).getChild(Ve(e));
    }
    hasChild(e) {
        return null !== this.children_.get(e);
    }
    updateImmediateChild(e, t) {
        if (a(t, "We should always be passing snapshot nodes"), ".priority" === e) return this.updatePriority(t);
        {
            const n = new rt(e, t);
            let i, s;
            t.isEmpty() ? (i = this.children_.remove(e), s = this.indexMap_.removeFromIndexes(n, this.children_)) : (i = this.children_.insert(e, t), s = this.indexMap_.addToIndexes(n, this.children_));
            const r = i.isEmpty() ? Pt : this.priorityNode_;
            return new xt(i, r, s);
        }
    }
    updateChild(e, t) {
        const n = je(e);
        if (null === n) return t;
        {
            a(".priority" !== je(e) || 1 === He(e), ".priority must be the last token in a path");
            const i = this.getImmediateChild(n).updateChild(Ve(e), t);
            return this.updateImmediateChild(n, i);
        }
    }
    isEmpty() {
        return this.children_.isEmpty();
    }
    numChildren() {
        return this.children_.count();
    }
    val(e) {
        if (this.isEmpty()) return null;
        const t = {};
        let n = 0, i = 0, s = !0;
        if (this.forEachChild(Tt, (r, o)=>{
            t[r] = o.val(e), n++, s && xt.INTEGER_REGEXP_.test(r) ? i = Math.max(i, Number(r)) : s = !1;
        }), !e && s && i < 2 * n) {
            const e = [];
            for(const n in t)e[n] = t[n];
            return e;
        }
        return e && !this.getPriority().isEmpty() && (t[".priority"] = this.getPriority().val()), t;
    }
    hash() {
        if (null === this.lazyHash_) {
            let e = "";
            this.getPriority().isEmpty() || (e += "priority:" + gt(this.getPriority().val()) + ":"), this.forEachChild(Tt, (t, n)=>{
                const i = n.hash();
                "" !== i && (e += ":" + t + ":" + i);
            }), this.lazyHash_ = "" === e ? "" : G(e);
        }
        return this.lazyHash_;
    }
    getPredecessorChildName(e, t, n) {
        const i = this.resolveIndex_(n);
        if (i) {
            const n = i.getPredecessorKey(new rt(e, t));
            return n ? n.name : null;
        }
        return this.children_.getPredecessorKey(e);
    }
    getFirstChildName(e) {
        const t = this.resolveIndex_(e);
        if (t) {
            const e = t.minKey();
            return e && e.name;
        }
        return this.children_.minKey();
    }
    getFirstChild(e) {
        const t = this.getFirstChildName(e);
        return t ? new rt(t, this.children_.get(t)) : null;
    }
    getLastChildName(e) {
        const t = this.resolveIndex_(e);
        if (t) {
            const e = t.maxKey();
            return e && e.name;
        }
        return this.children_.maxKey();
    }
    getLastChild(e) {
        const t = this.getLastChildName(e);
        return t ? new rt(t, this.children_.get(t)) : null;
    }
    forEachChild(e, t) {
        const n = this.resolveIndex_(e);
        return n ? n.inorderTraversal((e)=>t(e.name, e.node)) : this.children_.inorderTraversal(t);
    }
    getIterator(e) {
        return this.getIteratorFrom(e.minPost(), e);
    }
    getIteratorFrom(e, t) {
        const n = this.resolveIndex_(t);
        if (n) return n.getIteratorFrom(e, (e)=>e);
        {
            const n = this.children_.getIteratorFrom(e.name, rt.Wrap);
            let i = n.peek();
            for(; null != i && t.compare(i, e) < 0;)n.getNext(), i = n.peek();
            return n;
        }
    }
    getReverseIterator(e) {
        return this.getReverseIteratorFrom(e.maxPost(), e);
    }
    getReverseIteratorFrom(e, t) {
        const n = this.resolveIndex_(t);
        if (n) return n.getReverseIteratorFrom(e, (e)=>e);
        {
            const n = this.children_.getReverseIteratorFrom(e.name, rt.Wrap);
            let i = n.peek();
            for(; null != i && t.compare(i, e) > 0;)n.getNext(), i = n.peek();
            return n;
        }
    }
    compareTo(e) {
        return this.isEmpty() ? e.isEmpty() ? 0 : -1 : e.isLeafNode() || e.isEmpty() ? 1 : e === Rt ? -1 : 0;
    }
    withIndex(e) {
        if (e === ht || this.indexMap_.hasIndex(e)) return this;
        {
            const t = this.indexMap_.addIndex(e, this.children_);
            return new xt(this.children_, this.priorityNode_, t);
        }
    }
    isIndexed(e) {
        return e === ht || this.indexMap_.hasIndex(e);
    }
    equals(e) {
        if (e === this) return !0;
        if (e.isLeafNode()) return !1;
        {
            const t = e;
            if (this.getPriority().equals(t.getPriority())) {
                if (this.children_.count() === t.children_.count()) {
                    const e = this.getIterator(Tt), n = t.getIterator(Tt);
                    let i = e.getNext(), s = n.getNext();
                    for(; i && s;){
                        if (i.name !== s.name || !i.node.equals(s.node)) return !1;
                        i = e.getNext(), s = n.getNext();
                    }
                    return null === i && null === s;
                }
                return !1;
            }
            return !1;
        }
    }
    resolveIndex_(e) {
        return e === ht ? null : this.indexMap_.get(e.toString());
    }
}
xt.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
const Rt = new class extends xt {
    constructor(){
        super(new dt(pt), xt.EMPTY_NODE, Nt.Default);
    }
    compareTo(e) {
        return e === this ? 0 : 1;
    }
    equals(e) {
        return e === this;
    }
    getPriority() {
        return this;
    }
    getImmediateChild(e) {
        return xt.EMPTY_NODE;
    }
    isEmpty() {
        return !1;
    }
};
Object.defineProperties(rt, {
    MIN: {
        value: new rt(ae, xt.EMPTY_NODE)
    },
    MAX: {
        value: new rt(le, Rt)
    }
}), lt.__EMPTY_NODE = xt.EMPTY_NODE, wt.__childrenNodeConstructor = xt, ft = Rt, function(e) {
    Ct = e;
}(Rt);
function Dt(e, t = null) {
    if (null === e) return xt.EMPTY_NODE;
    if ("object" == typeof e && ".priority" in e && (t = e[".priority"]), a(null === t || "string" == typeof t || "number" == typeof t || "object" == typeof t && ".sv" in t, "Invalid priority type found: " + typeof t), "object" == typeof e && ".value" in e && null !== e[".value"] && (e = e[".value"]), "object" != typeof e || ".sv" in e) return new wt(e, Dt(t));
    if (e instanceof Array) {
        let n = xt.EMPTY_NODE;
        return pe(e, (t, i)=>{
            if (S(e, t) && "." !== t.substring(0, 1)) {
                const e = Dt(i);
                !e.isLeafNode() && e.isEmpty() || (n = n.updateImmediateChild(t, e));
            }
        }), n.updatePriority(Dt(t));
    }
    {
        const n = [];
        let i = !1;
        if (pe(e, (e, t)=>{
            if ("." !== e.substring(0, 1)) {
                const s = Dt(t);
                s.isEmpty() || (i = i || !s.getPriority().isEmpty(), n.push(new rt(e, s)));
            }
        }), 0 === n.length) return xt.EMPTY_NODE;
        const s = It(n, _t, (e)=>e.name, pt);
        if (i) {
            const e = It(n, Tt.getCompare());
            return new xt(s, Dt(t), new Nt({
                ".priority": e
            }, {
                ".priority": Tt
            }));
        }
        return new xt(s, Dt(t), Nt.Default);
    }
}
!function(e) {
    vt = e;
}(Dt);
class At extends ot {
    constructor(e){
        super(), this.indexPath_ = e, a(!$e(e) && ".priority" !== je(e), "Can't create PathIndex with empty path or .priority key");
    }
    extractChild(e) {
        return e.getChild(this.indexPath_);
    }
    isDefinedOn(e) {
        return !e.getChild(this.indexPath_).isEmpty();
    }
    compare(e, t) {
        const n = this.extractChild(e.node), i = this.extractChild(t.node), s = n.compareTo(i);
        return 0 === s ? he(e.name, t.name) : s;
    }
    makePost(e, t) {
        const n = Dt(e), i = xt.EMPTY_NODE.updateChild(this.indexPath_, n);
        return new rt(t, i);
    }
    maxPost() {
        const e = xt.EMPTY_NODE.updateChild(this.indexPath_, Rt);
        return new rt(le, e);
    }
    toString() {
        return Ye(this.indexPath_, 0).join("/");
    }
}
const Ot = new class extends ot {
    compare(e, t) {
        const n = e.node.compareTo(t.node);
        return 0 === n ? he(e.name, t.name) : n;
    }
    isDefinedOn(e) {
        return !0;
    }
    indexedValueChanged(e, t) {
        return !e.equals(t);
    }
    minPost() {
        return rt.MIN;
    }
    maxPost() {
        return rt.MAX;
    }
    makePost(e, t) {
        const n = Dt(e);
        return new rt(t, n);
    }
    toString() {
        return ".value";
    }
};
function Lt(e) {
    return {
        type: "value",
        snapshotNode: e
    };
}
function Ft(e, t) {
    return {
        type: "child_added",
        snapshotNode: t,
        childName: e
    };
}
function Mt(e, t) {
    return {
        type: "child_removed",
        snapshotNode: t,
        childName: e
    };
}
function qt(e, t, n) {
    return {
        type: "child_changed",
        snapshotNode: t,
        childName: e,
        oldSnap: n
    };
}
class Wt {
    constructor(e){
        this.index_ = e;
    }
    updateChild(e, t, n, i, s, r) {
        a(e.isIndexed(this.index_), "A node must be indexed if only a child is updated");
        const o = e.getImmediateChild(t);
        return o.getChild(i).equals(n.getChild(i)) && o.isEmpty() === n.isEmpty() ? e : (null != r && (n.isEmpty() ? e.hasChild(t) ? r.trackChildChange(Mt(t, o)) : a(e.isLeafNode(), "A child remove without an old child only makes sense on a leaf node") : o.isEmpty() ? r.trackChildChange(Ft(t, n)) : r.trackChildChange(qt(t, n, o))), e.isLeafNode() && n.isEmpty() ? e : e.updateImmediateChild(t, n).withIndex(this.index_));
    }
    updateFullNode(e, t, n) {
        return null != n && (e.isLeafNode() || e.forEachChild(Tt, (e, i)=>{
            t.hasChild(e) || n.trackChildChange(Mt(e, i));
        }), t.isLeafNode() || t.forEachChild(Tt, (t, i)=>{
            if (e.hasChild(t)) {
                const s = e.getImmediateChild(t);
                s.equals(i) || n.trackChildChange(qt(t, i, s));
            } else n.trackChildChange(Ft(t, i));
        })), t.withIndex(this.index_);
    }
    updatePriority(e, t) {
        return e.isEmpty() ? xt.EMPTY_NODE : e.updatePriority(t);
    }
    filtersNodes() {
        return !1;
    }
    getIndexedFilter() {
        return this;
    }
    getIndex() {
        return this.index_;
    }
}
class Ut {
    constructor(e){
        this.indexedFilter_ = new Wt(e.getIndex()), this.index_ = e.getIndex(), this.startPost_ = Ut.getStartPost_(e), this.endPost_ = Ut.getEndPost_(e), this.startIsInclusive_ = !e.startAfterSet_, this.endIsInclusive_ = !e.endBeforeSet_;
    }
    getStartPost() {
        return this.startPost_;
    }
    getEndPost() {
        return this.endPost_;
    }
    matches(e) {
        const t = this.startIsInclusive_ ? this.index_.compare(this.getStartPost(), e) <= 0 : this.index_.compare(this.getStartPost(), e) < 0, n = this.endIsInclusive_ ? this.index_.compare(e, this.getEndPost()) <= 0 : this.index_.compare(e, this.getEndPost()) < 0;
        return t && n;
    }
    updateChild(e, t, n, i, s, r) {
        return this.matches(new rt(t, n)) || (n = xt.EMPTY_NODE), this.indexedFilter_.updateChild(e, t, n, i, s, r);
    }
    updateFullNode(e, t, n) {
        t.isLeafNode() && (t = xt.EMPTY_NODE);
        let i = t.withIndex(this.index_);
        i = i.updatePriority(xt.EMPTY_NODE);
        const s = this;
        return t.forEachChild(Tt, (e, t)=>{
            s.matches(new rt(e, t)) || (i = i.updateImmediateChild(e, xt.EMPTY_NODE));
        }), this.indexedFilter_.updateFullNode(e, i, n);
    }
    updatePriority(e, t) {
        return e;
    }
    filtersNodes() {
        return !0;
    }
    getIndexedFilter() {
        return this.indexedFilter_;
    }
    getIndex() {
        return this.index_;
    }
    static getStartPost_(e) {
        if (e.hasStart()) {
            const t = e.getIndexStartName();
            return e.getIndex().makePost(e.getIndexStartValue(), t);
        }
        return e.getIndex().minPost();
    }
    static getEndPost_(e) {
        if (e.hasEnd()) {
            const t = e.getIndexEndName();
            return e.getIndex().makePost(e.getIndexEndValue(), t);
        }
        return e.getIndex().maxPost();
    }
}
class Bt {
    constructor(e){
        this.withinDirectionalStart = (e)=>this.reverse_ ? this.withinEndPost(e) : this.withinStartPost(e), this.withinDirectionalEnd = (e)=>this.reverse_ ? this.withinStartPost(e) : this.withinEndPost(e), this.withinStartPost = (e)=>{
            const t = this.index_.compare(this.rangedFilter_.getStartPost(), e);
            return this.startIsInclusive_ ? t <= 0 : t < 0;
        }, this.withinEndPost = (e)=>{
            const t = this.index_.compare(e, this.rangedFilter_.getEndPost());
            return this.endIsInclusive_ ? t <= 0 : t < 0;
        }, this.rangedFilter_ = new Ut(e), this.index_ = e.getIndex(), this.limit_ = e.getLimit(), this.reverse_ = !e.isViewFromLeft(), this.startIsInclusive_ = !e.startAfterSet_, this.endIsInclusive_ = !e.endBeforeSet_;
    }
    updateChild(e, t, n, i, s, r) {
        return this.rangedFilter_.matches(new rt(t, n)) || (n = xt.EMPTY_NODE), e.getImmediateChild(t).equals(n) ? e : e.numChildren() < this.limit_ ? this.rangedFilter_.getIndexedFilter().updateChild(e, t, n, i, s, r) : this.fullLimitUpdateChild_(e, t, n, s, r);
    }
    updateFullNode(e, t, n) {
        let i;
        if (t.isLeafNode() || t.isEmpty()) i = xt.EMPTY_NODE.withIndex(this.index_);
        else if (2 * this.limit_ < t.numChildren() && t.isIndexed(this.index_)) {
            let e;
            i = xt.EMPTY_NODE.withIndex(this.index_), e = this.reverse_ ? t.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_) : t.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
            let n = 0;
            for(; e.hasNext() && n < this.limit_;){
                const t = e.getNext();
                if (this.withinDirectionalStart(t)) {
                    if (!this.withinDirectionalEnd(t)) break;
                    i = i.updateImmediateChild(t.name, t.node), n++;
                }
            }
        } else {
            let e;
            i = t.withIndex(this.index_), i = i.updatePriority(xt.EMPTY_NODE), e = this.reverse_ ? i.getReverseIterator(this.index_) : i.getIterator(this.index_);
            let n = 0;
            for(; e.hasNext();){
                const t = e.getNext();
                n < this.limit_ && this.withinDirectionalStart(t) && this.withinDirectionalEnd(t) ? n++ : i = i.updateImmediateChild(t.name, xt.EMPTY_NODE);
            }
        }
        return this.rangedFilter_.getIndexedFilter().updateFullNode(e, i, n);
    }
    updatePriority(e, t) {
        return e;
    }
    filtersNodes() {
        return !0;
    }
    getIndexedFilter() {
        return this.rangedFilter_.getIndexedFilter();
    }
    getIndex() {
        return this.index_;
    }
    fullLimitUpdateChild_(e, t, n, i, s) {
        let r;
        if (this.reverse_) {
            const e = this.index_.getCompare();
            r = (t, n)=>e(n, t);
        } else r = this.index_.getCompare();
        const o = e;
        a(o.numChildren() === this.limit_, "");
        const l = new rt(t, n), h = this.reverse_ ? o.getFirstChild(this.index_) : o.getLastChild(this.index_), c = this.rangedFilter_.matches(l);
        if (o.hasChild(t)) {
            const e = o.getImmediateChild(t);
            let a = i.getChildAfterChild(this.index_, h, this.reverse_);
            for(; null != a && (a.name === t || o.hasChild(a.name));)a = i.getChildAfterChild(this.index_, a, this.reverse_);
            const u = null == a ? 1 : r(a, l);
            if (c && !n.isEmpty() && u >= 0) return null != s && s.trackChildChange(qt(t, n, e)), o.updateImmediateChild(t, n);
            {
                null != s && s.trackChildChange(Mt(t, e));
                const n = o.updateImmediateChild(t, xt.EMPTY_NODE);
                return null != a && this.rangedFilter_.matches(a) ? (null != s && s.trackChildChange(Ft(a.name, a.node)), n.updateImmediateChild(a.name, a.node)) : n;
            }
        }
        return n.isEmpty() ? e : c && r(h, l) >= 0 ? (null != s && (s.trackChildChange(Mt(h.name, h.node)), s.trackChildChange(Ft(t, n))), o.updateImmediateChild(t, n).updateImmediateChild(h.name, xt.EMPTY_NODE)) : e;
    }
}
class jt {
    constructor(){
        this.limitSet_ = !1, this.startSet_ = !1, this.startNameSet_ = !1, this.startAfterSet_ = !1, this.endSet_ = !1, this.endNameSet_ = !1, this.endBeforeSet_ = !1, this.limit_ = 0, this.viewFrom_ = "", this.indexStartValue_ = null, this.indexStartName_ = "", this.indexEndValue_ = null, this.indexEndName_ = "", this.index_ = Tt;
    }
    hasStart() {
        return this.startSet_;
    }
    isViewFromLeft() {
        return "" === this.viewFrom_ ? this.startSet_ : "l" === this.viewFrom_;
    }
    getIndexStartValue() {
        return a(this.startSet_, "Only valid if start has been set"), this.indexStartValue_;
    }
    getIndexStartName() {
        return a(this.startSet_, "Only valid if start has been set"), this.startNameSet_ ? this.indexStartName_ : ae;
    }
    hasEnd() {
        return this.endSet_;
    }
    getIndexEndValue() {
        return a(this.endSet_, "Only valid if end has been set"), this.indexEndValue_;
    }
    getIndexEndName() {
        return a(this.endSet_, "Only valid if end has been set"), this.endNameSet_ ? this.indexEndName_ : le;
    }
    hasLimit() {
        return this.limitSet_;
    }
    hasAnchoredLimit() {
        return this.limitSet_ && "" !== this.viewFrom_;
    }
    getLimit() {
        return a(this.limitSet_, "Only valid if limit has been set"), this.limit_;
    }
    getIndex() {
        return this.index_;
    }
    loadsAllData() {
        return !(this.startSet_ || this.endSet_ || this.limitSet_);
    }
    isDefault() {
        return this.loadsAllData() && this.index_ === Tt;
    }
    copy() {
        const e = new jt;
        return e.limitSet_ = this.limitSet_, e.limit_ = this.limit_, e.startSet_ = this.startSet_, e.startAfterSet_ = this.startAfterSet_, e.indexStartValue_ = this.indexStartValue_, e.startNameSet_ = this.startNameSet_, e.indexStartName_ = this.indexStartName_, e.endSet_ = this.endSet_, e.endBeforeSet_ = this.endBeforeSet_, e.indexEndValue_ = this.indexEndValue_, e.endNameSet_ = this.endNameSet_, e.indexEndName_ = this.indexEndName_, e.index_ = this.index_, e.viewFrom_ = this.viewFrom_, e;
    }
}
function Ht(e, t, n) {
    const i = e.copy();
    return i.startSet_ = !0, void 0 === t && (t = null), i.indexStartValue_ = t, null != n ? (i.startNameSet_ = !0, i.indexStartName_ = n) : (i.startNameSet_ = !1, i.indexStartName_ = ""), i;
}
function Vt(e, t, n) {
    const i = e.copy();
    return i.endSet_ = !0, void 0 === t && (t = null), i.indexEndValue_ = t, void 0 !== n ? (i.endNameSet_ = !0, i.indexEndName_ = n) : (i.endNameSet_ = !1, i.indexEndName_ = ""), i;
}
function zt(e, t) {
    const n = e.copy();
    return n.index_ = t, n;
}
function Yt(e) {
    const t = {};
    if (e.isDefault()) return t;
    let n;
    if (e.index_ === Tt ? n = "$priority" : e.index_ === Ot ? n = "$value" : e.index_ === ht ? n = "$key" : (a(e.index_ instanceof At, "Unrecognized index type!"), n = e.index_.toString()), t.orderBy = E(n), e.startSet_) {
        const n = e.startAfterSet_ ? "startAfter" : "startAt";
        t[n] = E(e.indexStartValue_), e.startNameSet_ && (t[n] += "," + E(e.indexStartName_));
    }
    if (e.endSet_) {
        const n = e.endBeforeSet_ ? "endBefore" : "endAt";
        t[n] = E(e.indexEndValue_), e.endNameSet_ && (t[n] += "," + E(e.indexEndName_));
    }
    return e.limitSet_ && (e.isViewFromLeft() ? t.limitToFirst = e.limit_ : t.limitToLast = e.limit_), t;
}
function Kt(e) {
    const t = {};
    if (e.startSet_ && (t.sp = e.indexStartValue_, e.startNameSet_ && (t.sn = e.indexStartName_), t.sin = !e.startAfterSet_), e.endSet_ && (t.ep = e.indexEndValue_, e.endNameSet_ && (t.en = e.indexEndName_), t.ein = !e.endBeforeSet_), e.limitSet_) {
        t.l = e.limit_;
        let n = e.viewFrom_;
        "" === n && (n = e.isViewFromLeft() ? "l" : "r"), t.vf = n;
    }
    return e.index_ !== Tt && (t.i = e.index_.toString()), t;
}
class Qt extends Me {
    constructor(e, t, n, i){
        super(), this.repoInfo_ = e, this.onDataUpdate_ = t, this.authTokenProvider_ = n, this.appCheckTokenProvider_ = i, this.log_ = ne("p:rest:"), this.listens_ = {};
    }
    reportStats(e) {
        throw new Error("Method not implemented.");
    }
    static getListenId_(e, t) {
        return void 0 !== t ? "tag$" + t : (a(e._queryParams.isDefault(), "should have a tag if it's not a default query."), e._path.toString());
    }
    listen(e, t, n, i) {
        const s = e._path.toString();
        this.log_("Listen called for " + s + " " + e._queryIdentifier);
        const r = Qt.getListenId_(e, n), o = {};
        this.listens_[r] = o;
        const a = Yt(e._queryParams);
        this.restRequest_(s + ".json", a, (e, t)=>{
            let a = t;
            if (404 === e && (a = null, e = null), null === e && this.onDataUpdate_(s, a, !1, n), k(this.listens_, r) === o) {
                let t;
                t = e ? 401 === e ? "permission_denied" : "rest_error:" + e : "ok", i(t, null);
            }
        });
    }
    unlisten(e, t) {
        const n = Qt.getListenId_(e, t);
        delete this.listens_[n];
    }
    get(e) {
        const t = Yt(e._queryParams), n = e._path.toString(), i = new C;
        return this.restRequest_(n + ".json", t, (e, t)=>{
            let s = t;
            404 === e && (s = null, e = null), null === e ? (this.onDataUpdate_(n, s, !1, null), i.resolve(s)) : i.reject(new Error(s));
        }), i.promise;
    }
    refreshAuthToken(e) {}
    restRequest_(e, t = {}, n) {
        return t.format = "export", Promise.all([
            this.authTokenProvider_.getToken(!1),
            this.appCheckTokenProvider_.getToken(!1)
        ]).then(([i, s])=>{
            i && i.accessToken && (t.auth = i.accessToken), s && s.token && (t.ac = s.token);
            const r = (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host + e + "?ns=" + this.repoInfo_.namespace + function(e) {
                const t = [];
                for (const [n, i] of Object.entries(e))Array.isArray(i) ? i.forEach((e)=>{
                    t.push(encodeURIComponent(n) + "=" + encodeURIComponent(e));
                }) : t.push(encodeURIComponent(n) + "=" + encodeURIComponent(i));
                return t.length ? "&" + t.join("&") : "";
            }(t);
            this.log_("Sending REST request for " + r);
            const o = new XMLHttpRequest;
            o.onreadystatechange = ()=>{
                if (n && 4 === o.readyState) {
                    this.log_("REST Response for " + r + " received. status:", o.status, "response:", o.responseText);
                    let e = null;
                    if (o.status >= 200 && o.status < 300) {
                        try {
                            e = b(o.responseText);
                        } catch (e) {
                            re("Failed to parse JSON response for " + r + ": " + o.responseText);
                        }
                        n(null, e);
                    } else 401 !== o.status && 404 !== o.status && re("Got unsuccessful REST response for " + r + " Status: " + o.status), n(o.status);
                    n = null;
                }
            }, o.open("GET", r, !0), o.send();
        });
    }
}
class $t {
    constructor(){
        this.rootNode_ = xt.EMPTY_NODE;
    }
    getNode(e) {
        return this.rootNode_.getChild(e);
    }
    updateSnapshot(e, t) {
        this.rootNode_ = this.rootNode_.updateChild(e, t);
    }
}
function Gt() {
    return {
        value: null,
        children: new Map
    };
}
function Jt(e, t, n) {
    if ($e(t)) e.value = n, e.children.clear();
    else if (null !== e.value) e.value = e.value.updateChild(t, n);
    else {
        const i = je(t);
        e.children.has(i) || e.children.set(i, Gt());
        Jt(e.children.get(i), t = Ve(t), n);
    }
}
function Xt(e, t) {
    if ($e(t)) return e.value = null, e.children.clear(), !0;
    if (null !== e.value) {
        if (e.value.isLeafNode()) return !1;
        {
            const n = e.value;
            return e.value = null, n.forEachChild(Tt, (t, n)=>{
                Jt(e, new Ue(t), n);
            }), Xt(e, t);
        }
    }
    if (e.children.size > 0) {
        const n = je(t);
        if (t = Ve(t), e.children.has(n)) Xt(e.children.get(n), t) && e.children.delete(n);
        return 0 === e.children.size;
    }
    return !0;
}
function Zt(e, t, n) {
    null !== e.value ? n(t, e.value) : function(e, t) {
        e.children.forEach((e, n)=>{
            t(n, e);
        });
    }(e, (e, i)=>{
        Zt(i, new Ue(t.toString() + "/" + e), n);
    });
}
class en {
    constructor(e){
        this.collection_ = e, this.last_ = null;
    }
    get() {
        const e = this.collection_.get(), t = Object.assign({}, e);
        return this.last_ && pe(this.last_, (e, n)=>{
            t[e] = t[e] - n;
        }), this.last_ = e, t;
    }
}
class tn {
    constructor(e, t){
        this.server_ = t, this.statsToReport_ = {}, this.statsListener_ = new en(e);
        const n = 1e4 + 2e4 * Math.random();
        ve(this.reportStats_.bind(this), Math.floor(n));
    }
    reportStats_() {
        const e = this.statsListener_.get(), t = {};
        let n = !1;
        pe(e, (e, i)=>{
            i > 0 && S(this.statsToReport_, e) && (t[e] = i, n = !0);
        }), n && this.server_.reportStats(t), ve(this.reportStats_.bind(this), Math.floor(2 * Math.random() * 3e5));
    }
}
var nn;
function sn(e) {
    return {
        fromUser: !1,
        fromServer: !0,
        queryId: e,
        tagged: !0
    };
}
!function(e) {
    e[e.OVERWRITE = 0] = "OVERWRITE", e[e.MERGE = 1] = "MERGE", e[e.ACK_USER_WRITE = 2] = "ACK_USER_WRITE", e[e.LISTEN_COMPLETE = 3] = "LISTEN_COMPLETE";
}(nn || (nn = {}));
class rn {
    constructor(e, t, n){
        this.path = e, this.affectedTree = t, this.revert = n, this.type = nn.ACK_USER_WRITE, this.source = {
            fromUser: !0,
            fromServer: !1,
            queryId: null,
            tagged: !1
        };
    }
    operationForChild(e) {
        if ($e(this.path)) {
            if (null != this.affectedTree.value) return a(this.affectedTree.children.isEmpty(), "affectedTree should not have overlapping affected paths."), this;
            {
                const t = this.affectedTree.subtree(new Ue(e));
                return new rn(Be(), t, this.revert);
            }
        }
        return a(je(this.path) === e, "operationForChild called for unrelated child."), new rn(Ve(this.path), this.affectedTree, this.revert);
    }
}
class on {
    constructor(e, t){
        this.source = e, this.path = t, this.type = nn.LISTEN_COMPLETE;
    }
    operationForChild(e) {
        return $e(this.path) ? new on(this.source, Be()) : new on(this.source, Ve(this.path));
    }
}
class an {
    constructor(e, t, n){
        this.source = e, this.path = t, this.snap = n, this.type = nn.OVERWRITE;
    }
    operationForChild(e) {
        return $e(this.path) ? new an(this.source, Be(), this.snap.getImmediateChild(e)) : new an(this.source, Ve(this.path), this.snap);
    }
}
class ln {
    constructor(e, t, n){
        this.source = e, this.path = t, this.children = n, this.type = nn.MERGE;
    }
    operationForChild(e) {
        if ($e(this.path)) {
            const t = this.children.subtree(new Ue(e));
            return t.isEmpty() ? null : t.value ? new an(this.source, Be(), t.value) : new ln(this.source, Be(), t);
        }
        return a(je(this.path) === e, "Can't get a merge for a child not on the path of the operation"), new ln(this.source, Ve(this.path), this.children);
    }
    toString() {
        return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")";
    }
}
class hn {
    constructor(e, t, n){
        this.node_ = e, this.fullyInitialized_ = t, this.filtered_ = n;
    }
    isFullyInitialized() {
        return this.fullyInitialized_;
    }
    isFiltered() {
        return this.filtered_;
    }
    isCompleteForPath(e) {
        if ($e(e)) return this.isFullyInitialized() && !this.filtered_;
        const t = je(e);
        return this.isCompleteForChild(t);
    }
    isCompleteForChild(e) {
        return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(e);
    }
    getNode() {
        return this.node_;
    }
}
class cn {
    constructor(e){
        this.query_ = e, this.index_ = this.query_._queryParams.getIndex();
    }
}
function un(e, t, n, i, s, r) {
    const o = i.filter((e)=>e.type === n);
    o.sort((t, n)=>(function(e, t, n) {
            if (null == t.childName || null == n.childName) throw l("Should only compare child_ events.");
            const i = new rt(t.childName, t.snapshotNode), s = new rt(n.childName, n.snapshotNode);
            return e.index_.compare(i, s);
        })(e, t, n)), o.forEach((n)=>{
        const i = function(e, t, n) {
            return "value" === t.type || "child_removed" === t.type || (t.prevName = n.getPredecessorChildName(t.childName, t.snapshotNode, e.index_)), t;
        }(e, n, r);
        s.forEach((s)=>{
            s.respondsTo(n.type) && t.push(s.createEvent(i, e.query_));
        });
    });
}
function dn(e, t) {
    return {
        eventCache: e,
        serverCache: t
    };
}
function _n(e, t, n, i) {
    return dn(new hn(t, n, i), e.serverCache);
}
function pn(e, t, n, i) {
    return dn(e.eventCache, new hn(t, n, i));
}
function fn(e) {
    return e.eventCache.isFullyInitialized() ? e.eventCache.getNode() : null;
}
function gn(e) {
    return e.serverCache.isFullyInitialized() ? e.serverCache.getNode() : null;
}
let mn;
class yn {
    constructor(e, t = (()=>(mn || (mn = new dt(ce)), mn))()){
        this.value = e, this.children = t;
    }
    static fromObject(e) {
        let t = new yn(null);
        return pe(e, (e, n)=>{
            t = t.set(new Ue(e), n);
        }), t;
    }
    isEmpty() {
        return null === this.value && this.children.isEmpty();
    }
    findRootMostMatchingPathAndValue(e, t) {
        if (null != this.value && t(this.value)) return {
            path: Be(),
            value: this.value
        };
        if ($e(e)) return null;
        {
            const n = je(e), i = this.children.get(n);
            if (null !== i) {
                const s = i.findRootMostMatchingPathAndValue(Ve(e), t);
                if (null != s) return {
                    path: Qe(new Ue(n), s.path),
                    value: s.value
                };
                return null;
            }
            return null;
        }
    }
    findRootMostValueAndPath(e) {
        return this.findRootMostMatchingPathAndValue(e, ()=>!0);
    }
    subtree(e) {
        if ($e(e)) return this;
        {
            const t = je(e), n = this.children.get(t);
            return null !== n ? n.subtree(Ve(e)) : new yn(null);
        }
    }
    set(e, t) {
        if ($e(e)) return new yn(t, this.children);
        {
            const n = je(e), i = (this.children.get(n) || new yn(null)).set(Ve(e), t), s = this.children.insert(n, i);
            return new yn(this.value, s);
        }
    }
    remove(e) {
        if ($e(e)) return this.children.isEmpty() ? new yn(null) : new yn(null, this.children);
        {
            const t = je(e), n = this.children.get(t);
            if (n) {
                const i = n.remove(Ve(e));
                let s;
                return s = i.isEmpty() ? this.children.remove(t) : this.children.insert(t, i), null === this.value && s.isEmpty() ? new yn(null) : new yn(this.value, s);
            }
            return this;
        }
    }
    get(e) {
        if ($e(e)) return this.value;
        {
            const t = je(e), n = this.children.get(t);
            return n ? n.get(Ve(e)) : null;
        }
    }
    setTree(e, t) {
        if ($e(e)) return t;
        {
            const n = je(e), i = (this.children.get(n) || new yn(null)).setTree(Ve(e), t);
            let s;
            return s = i.isEmpty() ? this.children.remove(n) : this.children.insert(n, i), new yn(this.value, s);
        }
    }
    fold(e) {
        return this.fold_(Be(), e);
    }
    fold_(e, t) {
        const n = {};
        return this.children.inorderTraversal((i, s)=>{
            n[i] = s.fold_(Qe(e, i), t);
        }), t(e, this.value, n);
    }
    findOnPath(e, t) {
        return this.findOnPath_(e, Be(), t);
    }
    findOnPath_(e, t, n) {
        const i = !!this.value && n(t, this.value);
        if (i) return i;
        if ($e(e)) return null;
        {
            const i = je(e), s = this.children.get(i);
            return s ? s.findOnPath_(Ve(e), Qe(t, i), n) : null;
        }
    }
    foreachOnPath(e, t) {
        return this.foreachOnPath_(e, Be(), t);
    }
    foreachOnPath_(e, t, n) {
        if ($e(e)) return this;
        {
            this.value && n(t, this.value);
            const i = je(e), s = this.children.get(i);
            return s ? s.foreachOnPath_(Ve(e), Qe(t, i), n) : new yn(null);
        }
    }
    foreach(e) {
        this.foreach_(Be(), e);
    }
    foreach_(e, t) {
        this.children.inorderTraversal((n, i)=>{
            i.foreach_(Qe(e, n), t);
        }), this.value && t(e, this.value);
    }
    foreachChild(e) {
        this.children.inorderTraversal((t, n)=>{
            n.value && e(t, n.value);
        });
    }
}
class vn {
    constructor(e){
        this.writeTree_ = e;
    }
    static empty() {
        return new vn(new yn(null));
    }
}
function Cn(e, t, n) {
    if ($e(t)) return new vn(new yn(n));
    {
        const i = e.writeTree_.findRootMostValueAndPath(t);
        if (null != i) {
            const s = i.path;
            let r = i.value;
            const o = Ge(s, t);
            return r = r.updateChild(o, n), new vn(e.writeTree_.set(s, r));
        }
        {
            const i = new yn(n), s = e.writeTree_.setTree(t, i);
            return new vn(s);
        }
    }
}
function wn(e, t, n) {
    let i = e;
    return pe(n, (e, n)=>{
        i = Cn(i, Qe(t, e), n);
    }), i;
}
function Tn(e, t) {
    if ($e(t)) return vn.empty();
    {
        const n = e.writeTree_.setTree(t, new yn(null));
        return new vn(n);
    }
}
function bn(e, t) {
    return null != En(e, t);
}
function En(e, t) {
    const n = e.writeTree_.findRootMostValueAndPath(t);
    return null != n ? e.writeTree_.get(n.path).getChild(Ge(n.path, t)) : null;
}
function In(e) {
    const t = [], n = e.writeTree_.value;
    return null != n ? n.isLeafNode() || n.forEachChild(Tt, (e, n)=>{
        t.push(new rt(e, n));
    }) : e.writeTree_.children.inorderTraversal((e, n)=>{
        null != n.value && t.push(new rt(e, n.value));
    }), t;
}
function Sn(e, t) {
    if ($e(t)) return e;
    {
        const n = En(e, t);
        return new vn(null != n ? new yn(n) : e.writeTree_.subtree(t));
    }
}
function kn(e) {
    return e.writeTree_.isEmpty();
}
function Nn(e, t) {
    return Pn(Be(), e.writeTree_, t);
}
function Pn(e, t, n) {
    if (null != t.value) return n.updateChild(e, t.value);
    {
        let i = null;
        return t.children.inorderTraversal((t, s)=>{
            ".priority" === t ? (a(null !== s.value, "Priority writes must always be leaf nodes"), i = s.value) : n = Pn(Qe(e, t), s, n);
        }), n.getChild(e).isEmpty() || null === i || (n = n.updateChild(Qe(e, ".priority"), i)), n;
    }
}
function xn(e, t) {
    return Hn(t, e);
}
function Rn(e, t) {
    const n = e.allWrites.findIndex((e)=>e.writeId === t);
    a(n >= 0, "removeWrite called with nonexistent writeId.");
    const i = e.allWrites[n];
    e.allWrites.splice(n, 1);
    let s = i.visible, r = !1, o = e.allWrites.length - 1;
    for(; s && o >= 0;){
        const t = e.allWrites[o];
        t.visible && (o >= n && Dn(t, i.path) ? s = !1 : Ze(i.path, t.path) && (r = !0)), o--;
    }
    if (s) {
        if (r) return function(e) {
            e.visibleWrites = On(e.allWrites, An, Be()), e.allWrites.length > 0 ? e.lastWriteId = e.allWrites[e.allWrites.length - 1].writeId : e.lastWriteId = -1;
        }(e), !0;
        if (i.snap) e.visibleWrites = Tn(e.visibleWrites, i.path);
        else pe(i.children, (t)=>{
            e.visibleWrites = Tn(e.visibleWrites, Qe(i.path, t));
        });
        return !0;
    }
    return !1;
}
function Dn(e, t) {
    if (e.snap) return Ze(e.path, t);
    for(const n in e.children)if (e.children.hasOwnProperty(n) && Ze(Qe(e.path, n), t)) return !0;
    return !1;
}
function An(e) {
    return e.visible;
}
function On(e, t, n) {
    let i = vn.empty();
    for(let s = 0; s < e.length; ++s){
        const r = e[s];
        if (t(r)) {
            const e = r.path;
            let t;
            if (r.snap) Ze(n, e) ? (t = Ge(n, e), i = Cn(i, t, r.snap)) : Ze(e, n) && (t = Ge(e, n), i = Cn(i, Be(), r.snap.getChild(t)));
            else {
                if (!r.children) throw l("WriteRecord should have .snap or .children");
                if (Ze(n, e)) t = Ge(n, e), i = wn(i, t, r.children);
                else if (Ze(e, n)) {
                    if (t = Ge(e, n), $e(t)) i = wn(i, Be(), r.children);
                    else {
                        const e = k(r.children, je(t));
                        if (e) {
                            const n = e.getChild(Ve(t));
                            i = Cn(i, Be(), n);
                        }
                    }
                }
            }
        }
    }
    return i;
}
function Ln(e, t, n, i, s) {
    if (i || s) {
        const r = Sn(e.visibleWrites, t);
        if (!s && kn(r)) return n;
        if (s || null != n || bn(r, Be())) {
            const r = function(e) {
                return (e.visible || s) && (!i || !~i.indexOf(e.writeId)) && (Ze(e.path, t) || Ze(t, e.path));
            };
            return Nn(On(e.allWrites, r, t), n || xt.EMPTY_NODE);
        }
        return null;
    }
    {
        const i = En(e.visibleWrites, t);
        if (null != i) return i;
        {
            const i = Sn(e.visibleWrites, t);
            if (kn(i)) return n;
            if (null != n || bn(i, Be())) return Nn(i, n || xt.EMPTY_NODE);
            return null;
        }
    }
}
function Fn(e, t, n, i) {
    return Ln(e.writeTree, e.treePath, t, n, i);
}
function Mn(e, t) {
    return function(e, t, n) {
        let i = xt.EMPTY_NODE;
        const s = En(e.visibleWrites, t);
        if (s) return s.isLeafNode() || s.forEachChild(Tt, (e, t)=>{
            i = i.updateImmediateChild(e, t);
        }), i;
        if (n) {
            const s = Sn(e.visibleWrites, t);
            return n.forEachChild(Tt, (e, t)=>{
                const n = Nn(Sn(s, new Ue(e)), t);
                i = i.updateImmediateChild(e, n);
            }), In(s).forEach((e)=>{
                i = i.updateImmediateChild(e.name, e.node);
            }), i;
        }
        return In(Sn(e.visibleWrites, t)).forEach((e)=>{
            i = i.updateImmediateChild(e.name, e.node);
        }), i;
    }(e.writeTree, e.treePath, t);
}
function qn(e, t, n, i) {
    return function(e, t, n, i, s) {
        a(i || s, "Either existingEventSnap or existingServerSnap must exist");
        const r = Qe(t, n);
        if (bn(e.visibleWrites, r)) return null;
        {
            const t = Sn(e.visibleWrites, r);
            return kn(t) ? s.getChild(n) : Nn(t, s.getChild(n));
        }
    }(e.writeTree, e.treePath, t, n, i);
}
function Wn(e, t) {
    return function(e, t) {
        return En(e.visibleWrites, t);
    }(e.writeTree, Qe(e.treePath, t));
}
function Un(e, t, n, i, s, r) {
    return function(e, t, n, i, s, r, o) {
        let a;
        const l = Sn(e.visibleWrites, t), h = En(l, Be());
        if (null != h) a = h;
        else {
            if (null == n) return [];
            a = Nn(l, n);
        }
        if (a = a.withIndex(o), a.isEmpty() || a.isLeafNode()) return [];
        {
            const e = [], t = o.getCompare(), n = r ? a.getReverseIteratorFrom(i, o) : a.getIteratorFrom(i, o);
            let l = n.getNext();
            for(; l && e.length < s;)0 !== t(l, i) && e.push(l), l = n.getNext();
            return e;
        }
    }(e.writeTree, e.treePath, t, n, i, s, r);
}
function Bn(e, t, n) {
    return function(e, t, n, i) {
        const s = Qe(t, n), r = En(e.visibleWrites, s);
        if (null != r) return r;
        if (i.isCompleteForChild(n)) return Nn(Sn(e.visibleWrites, s), i.getNode().getImmediateChild(n));
        return null;
    }(e.writeTree, e.treePath, t, n);
}
function jn(e, t) {
    return Hn(Qe(e.treePath, t), e.writeTree);
}
function Hn(e, t) {
    return {
        treePath: e,
        writeTree: t
    };
}
class Vn {
    constructor(){
        this.changeMap = new Map;
    }
    trackChildChange(e) {
        const t = e.type, n = e.childName;
        a("child_added" === t || "child_changed" === t || "child_removed" === t, "Only child changes supported for tracking"), a(".priority" !== n, "Only non-priority child changes can be tracked.");
        const i = this.changeMap.get(n);
        if (i) {
            const s = i.type;
            if ("child_added" === t && "child_removed" === s) this.changeMap.set(n, qt(n, e.snapshotNode, i.snapshotNode));
            else if ("child_removed" === t && "child_added" === s) this.changeMap.delete(n);
            else if ("child_removed" === t && "child_changed" === s) this.changeMap.set(n, Mt(n, i.oldSnap));
            else if ("child_changed" === t && "child_added" === s) this.changeMap.set(n, Ft(n, e.snapshotNode));
            else {
                if ("child_changed" !== t || "child_changed" !== s) throw l("Illegal combination of changes: " + e + " occurred after " + i);
                this.changeMap.set(n, qt(n, e.snapshotNode, i.oldSnap));
            }
        } else this.changeMap.set(n, e);
    }
    getChanges() {
        return Array.from(this.changeMap.values());
    }
}
const zn = new class {
    getCompleteChild(e) {
        return null;
    }
    getChildAfterChild(e, t, n) {
        return null;
    }
};
class Yn {
    constructor(e, t, n = null){
        this.writes_ = e, this.viewCache_ = t, this.optCompleteServerCache_ = n;
    }
    getCompleteChild(e) {
        const t = this.viewCache_.eventCache;
        if (t.isCompleteForChild(e)) return t.getNode().getImmediateChild(e);
        {
            const t = null != this.optCompleteServerCache_ ? new hn(this.optCompleteServerCache_, !0, !1) : this.viewCache_.serverCache;
            return Bn(this.writes_, e, t);
        }
    }
    getChildAfterChild(e, t, n) {
        const i = null != this.optCompleteServerCache_ ? this.optCompleteServerCache_ : gn(this.viewCache_), s = Un(this.writes_, i, t, 1, n, e);
        return 0 === s.length ? null : s[0];
    }
}
function Kn(e, t, n, i, s) {
    const r = new Vn;
    let o, h;
    if (n.type === nn.OVERWRITE) {
        const l = n;
        l.source.fromUser ? o = Gn(e, t, l.path, l.snap, i, s, r) : (a(l.source.fromServer, "Unknown source."), h = l.source.tagged || t.serverCache.isFiltered() && !$e(l.path), o = $n(e, t, l.path, l.snap, i, s, h, r));
    } else if (n.type === nn.MERGE) {
        const l = n;
        l.source.fromUser ? o = function(e, t, n, i, s, r, o) {
            let a = t;
            return i.foreach((i, l)=>{
                const h = Qe(n, i);
                Jn(t, je(h)) && (a = Gn(e, a, h, l, s, r, o));
            }), i.foreach((i, l)=>{
                const h = Qe(n, i);
                Jn(t, je(h)) || (a = Gn(e, a, h, l, s, r, o));
            }), a;
        }(e, t, l.path, l.children, i, s, r) : (a(l.source.fromServer, "Unknown source."), h = l.source.tagged || t.serverCache.isFiltered(), o = Zn(e, t, l.path, l.children, i, s, h, r));
    } else if (n.type === nn.ACK_USER_WRITE) {
        const l = n;
        o = l.revert ? function(e, t, n, i, s, r) {
            let o;
            if (null != Wn(i, n)) return t;
            {
                const l = new Yn(i, t, s), h = t.eventCache.getNode();
                let c;
                if ($e(n) || ".priority" === je(n)) {
                    let n;
                    if (t.serverCache.isFullyInitialized()) n = Fn(i, gn(t));
                    else {
                        const e = t.serverCache.getNode();
                        a(e instanceof xt, "serverChildren would be complete if leaf node"), n = Mn(i, e);
                    }
                    n, c = e.filter.updateFullNode(h, n, r);
                } else {
                    const s = je(n);
                    let a = Bn(i, s, t.serverCache);
                    null == a && t.serverCache.isCompleteForChild(s) && (a = h.getImmediateChild(s)), c = null != a ? e.filter.updateChild(h, s, a, Ve(n), l, r) : t.eventCache.getNode().hasChild(s) ? e.filter.updateChild(h, s, xt.EMPTY_NODE, Ve(n), l, r) : h, c.isEmpty() && t.serverCache.isFullyInitialized() && (o = Fn(i, gn(t)), o.isLeafNode() && (c = e.filter.updateFullNode(c, o, r)));
                }
                return o = t.serverCache.isFullyInitialized() || null != Wn(i, Be()), _n(t, c, o, e.filter.filtersNodes());
            }
        }(e, t, l.path, i, s, r) : function(e, t, n, i, s, r, o) {
            if (null != Wn(s, n)) return t;
            const a = t.serverCache.isFiltered(), l = t.serverCache;
            if (null != i.value) {
                if ($e(n) && l.isFullyInitialized() || l.isCompleteForPath(n)) return $n(e, t, n, l.getNode().getChild(n), s, r, a, o);
                if ($e(n)) {
                    let i = new yn(null);
                    return l.getNode().forEachChild(ht, (e, t)=>{
                        i = i.set(new Ue(e), t);
                    }), Zn(e, t, n, i, s, r, a, o);
                }
                return t;
            }
            {
                let h = new yn(null);
                return i.foreach((e, t)=>{
                    const i = Qe(n, e);
                    l.isCompleteForPath(i) && (h = h.set(e, l.getNode().getChild(i)));
                }), Zn(e, t, n, h, s, r, a, o);
            }
        }(e, t, l.path, l.affectedTree, i, s, r);
    } else {
        if (n.type !== nn.LISTEN_COMPLETE) throw l("Unknown operation type: " + n.type);
        o = function(e, t, n, i, s) {
            const r = t.serverCache, o = pn(t, r.getNode(), r.isFullyInitialized() || $e(n), r.isFiltered());
            return Qn(e, o, n, i, zn, s);
        }(e, t, n.path, i, r);
    }
    const c = r.getChanges();
    return function(e, t, n) {
        const i = t.eventCache;
        if (i.isFullyInitialized()) {
            const s = i.getNode().isLeafNode() || i.getNode().isEmpty(), r = fn(e);
            (n.length > 0 || !e.eventCache.isFullyInitialized() || s && !i.getNode().equals(r) || !i.getNode().getPriority().equals(r.getPriority())) && n.push(Lt(fn(t)));
        }
    }(t, o, c), {
        viewCache: o,
        changes: c
    };
}
function Qn(e, t, n, i, s, r) {
    const o = t.eventCache;
    if (null != Wn(i, n)) return t;
    {
        let l, h;
        if ($e(n)) {
            if (a(t.serverCache.isFullyInitialized(), "If change path is empty, we must have complete server data"), t.serverCache.isFiltered()) {
                const n = gn(t), s = Mn(i, n instanceof xt ? n : xt.EMPTY_NODE);
                l = e.filter.updateFullNode(t.eventCache.getNode(), s, r);
            } else {
                const n = Fn(i, gn(t));
                l = e.filter.updateFullNode(t.eventCache.getNode(), n, r);
            }
        } else {
            const c = je(n);
            if (".priority" === c) {
                a(1 === He(n), "Can't have a priority with additional path components");
                const s = o.getNode();
                h = t.serverCache.getNode();
                const r = qn(i, n, s, h);
                l = null != r ? e.filter.updatePriority(s, r) : o.getNode();
            } else {
                const a = Ve(n);
                let u;
                if (o.isCompleteForChild(c)) {
                    h = t.serverCache.getNode();
                    const e = qn(i, n, o.getNode(), h);
                    u = null != e ? o.getNode().getImmediateChild(c).updateChild(a, e) : o.getNode().getImmediateChild(c);
                } else u = Bn(i, c, t.serverCache);
                l = null != u ? e.filter.updateChild(o.getNode(), c, u, a, s, r) : o.getNode();
            }
        }
        return _n(t, l, o.isFullyInitialized() || $e(n), e.filter.filtersNodes());
    }
}
function $n(e, t, n, i, s, r, o, a) {
    const l = t.serverCache;
    let h;
    const c = o ? e.filter : e.filter.getIndexedFilter();
    if ($e(n)) h = c.updateFullNode(l.getNode(), i, null);
    else if (c.filtersNodes() && !l.isFiltered()) {
        const e = l.getNode().updateChild(n, i);
        h = c.updateFullNode(l.getNode(), e, null);
    } else {
        const e = je(n);
        if (!l.isCompleteForPath(n) && He(n) > 1) return t;
        const s = Ve(n), r = l.getNode().getImmediateChild(e).updateChild(s, i);
        h = ".priority" === e ? c.updatePriority(l.getNode(), r) : c.updateChild(l.getNode(), e, r, s, zn, null);
    }
    const u = pn(t, h, l.isFullyInitialized() || $e(n), c.filtersNodes());
    return Qn(e, u, n, s, new Yn(s, u, r), a);
}
function Gn(e, t, n, i, s, r, o) {
    const a = t.eventCache;
    let l, h;
    const c = new Yn(s, t, r);
    if ($e(n)) h = e.filter.updateFullNode(t.eventCache.getNode(), i, o), l = _n(t, h, !0, e.filter.filtersNodes());
    else {
        const s = je(n);
        if (".priority" === s) h = e.filter.updatePriority(t.eventCache.getNode(), i), l = _n(t, h, a.isFullyInitialized(), a.isFiltered());
        else {
            const r = Ve(n), h = a.getNode().getImmediateChild(s);
            let u;
            if ($e(r)) u = i;
            else {
                const e = c.getCompleteChild(s);
                u = null != e ? ".priority" === ze(r) && e.getChild(Ke(r)).isEmpty() ? e : e.updateChild(r, i) : xt.EMPTY_NODE;
            }
            if (h.equals(u)) l = t;
            else l = _n(t, e.filter.updateChild(a.getNode(), s, u, r, c, o), a.isFullyInitialized(), e.filter.filtersNodes());
        }
    }
    return l;
}
function Jn(e, t) {
    return e.eventCache.isCompleteForChild(t);
}
function Xn(e, t, n) {
    return n.foreach((e, n)=>{
        t = t.updateChild(e, n);
    }), t;
}
function Zn(e, t, n, i, s, r, o, a) {
    if (t.serverCache.getNode().isEmpty() && !t.serverCache.isFullyInitialized()) return t;
    let l, h = t;
    l = $e(n) ? i : new yn(null).setTree(n, i);
    const c = t.serverCache.getNode();
    return l.children.inorderTraversal((n, i)=>{
        if (c.hasChild(n)) {
            const l = Xn(0, t.serverCache.getNode().getImmediateChild(n), i);
            h = $n(e, h, new Ue(n), l, s, r, o, a);
        }
    }), l.children.inorderTraversal((n, i)=>{
        const l = !t.serverCache.isCompleteForChild(n) && null === i.value;
        if (!c.hasChild(n) && !l) {
            const l = Xn(0, t.serverCache.getNode().getImmediateChild(n), i);
            h = $n(e, h, new Ue(n), l, s, r, o, a);
        }
    }), h;
}
class ei {
    constructor(e, t){
        this.query_ = e, this.eventRegistrations_ = [];
        const n = this.query_._queryParams, i = new Wt(n.getIndex()), s = (r = n).loadsAllData() ? new Wt(r.getIndex()) : r.hasLimit() ? new Bt(r) : new Ut(r);
        var r;
        this.processor_ = function(e) {
            return {
                filter: e
            };
        }(s);
        const o = t.serverCache, a = t.eventCache, l = i.updateFullNode(xt.EMPTY_NODE, o.getNode(), null), h = s.updateFullNode(xt.EMPTY_NODE, a.getNode(), null), c = new hn(l, o.isFullyInitialized(), i.filtersNodes()), u = new hn(h, a.isFullyInitialized(), s.filtersNodes());
        this.viewCache_ = dn(u, c), this.eventGenerator_ = new cn(this.query_);
    }
    get query() {
        return this.query_;
    }
}
function ti(e, t) {
    const n = gn(e.viewCache_);
    return n && (e.query._queryParams.loadsAllData() || !$e(t) && !n.getImmediateChild(je(t)).isEmpty()) ? n.getChild(t) : null;
}
function ni(e) {
    return 0 === e.eventRegistrations_.length;
}
function ii(e, t, n) {
    const i = [];
    if (n) {
        a(null == t, "A cancel should cancel all event registrations.");
        const s = e.query._path;
        e.eventRegistrations_.forEach((e)=>{
            const t = e.createCancelEvent(n, s);
            t && i.push(t);
        });
    }
    if (t) {
        let n = [];
        for(let i = 0; i < e.eventRegistrations_.length; ++i){
            const s = e.eventRegistrations_[i];
            if (s.matches(t)) {
                if (t.hasAnyCallback()) {
                    n = n.concat(e.eventRegistrations_.slice(i + 1));
                    break;
                }
            } else n.push(s);
        }
        e.eventRegistrations_ = n;
    } else e.eventRegistrations_ = [];
    return i;
}
function si(e, t, n, i) {
    t.type === nn.MERGE && null !== t.source.queryId && (a(gn(e.viewCache_), "We should always have a full cache before handling merges"), a(fn(e.viewCache_), "Missing event cache, even though we have a server cache"));
    const s = e.viewCache_, r = Kn(e.processor_, s, t, n, i);
    var o, l;
    return o = e.processor_, l = r.viewCache, a(l.eventCache.getNode().isIndexed(o.filter.getIndex()), "Event snap not indexed"), a(l.serverCache.getNode().isIndexed(o.filter.getIndex()), "Server snap not indexed"), a(r.viewCache.serverCache.isFullyInitialized() || !s.serverCache.isFullyInitialized(), "Once a server snap is complete, it should never go back"), e.viewCache_ = r.viewCache, ri(e, r.changes, r.viewCache.eventCache.getNode(), null);
}
function ri(e, t, n, i) {
    const s = i ? [
        i
    ] : e.eventRegistrations_;
    return function(e, t, n, i) {
        const s = [], r = [];
        return t.forEach((t)=>{
            var n;
            "child_changed" === t.type && e.index_.indexedValueChanged(t.oldSnap, t.snapshotNode) && r.push((n = t.childName, {
                type: "child_moved",
                snapshotNode: t.snapshotNode,
                childName: n
            }));
        }), un(e, s, "child_removed", t, i, n), un(e, s, "child_added", t, i, n), un(e, s, "child_moved", r, i, n), un(e, s, "child_changed", t, i, n), un(e, s, "value", t, i, n), s;
    }(e.eventGenerator_, t, n, s);
}
let oi, ai;
class li {
    constructor(){
        this.views = new Map;
    }
}
function hi(e, t, n, i) {
    const s = t.source.queryId;
    if (null !== s) {
        const r = e.views.get(s);
        return a(null != r, "SyncTree gave us an op for an invalid query."), si(r, t, n, i);
    }
    {
        let s = [];
        for (const r of e.views.values())s = s.concat(si(r, t, n, i));
        return s;
    }
}
function ci(e, t, n, i, s) {
    const r = t._queryIdentifier, o = e.views.get(r);
    if (!o) {
        let e = Fn(n, s ? i : null), r = !1;
        e ? r = !0 : i instanceof xt ? (e = Mn(n, i), r = !1) : (e = xt.EMPTY_NODE, r = !1);
        const o = dn(new hn(e, r, !1), new hn(i, s, !1));
        return new ei(t, o);
    }
    return o;
}
function ui(e, t, n, i, s, r) {
    const o = ci(e, t, i, s, r);
    return e.views.has(t._queryIdentifier) || e.views.set(t._queryIdentifier, o), function(e, t) {
        e.eventRegistrations_.push(t);
    }(o, n), function(e, t) {
        const n = e.viewCache_.eventCache, i = [];
        n.getNode().isLeafNode() || n.getNode().forEachChild(Tt, (e, t)=>{
            i.push(Ft(e, t));
        });
        return n.isFullyInitialized() && i.push(Lt(n.getNode())), ri(e, i, n.getNode(), t);
    }(o, n);
}
function di(e, t, n, i) {
    const s = t._queryIdentifier, r = [];
    let o = [];
    const l = mi(e);
    if ("default" === s) for (const [t, s] of e.views.entries())o = o.concat(ii(s, n, i)), ni(s) && (e.views.delete(t), s.query._queryParams.loadsAllData() || r.push(s.query));
    else {
        const t = e.views.get(s);
        t && (o = o.concat(ii(t, n, i)), ni(t) && (e.views.delete(s), t.query._queryParams.loadsAllData() || r.push(t.query)));
    }
    return l && !mi(e) && r.push(new (a(oi, "Reference.ts has not been loaded"), oi)(t._repo, t._path)), {
        removed: r,
        events: o
    };
}
function _i(e) {
    const t = [];
    for (const n of e.views.values())n.query._queryParams.loadsAllData() || t.push(n);
    return t;
}
function pi(e, t) {
    let n = null;
    for (const i of e.views.values())n = n || ti(i, t);
    return n;
}
function fi(e, t) {
    if (t._queryParams.loadsAllData()) return yi(e);
    {
        const n = t._queryIdentifier;
        return e.views.get(n);
    }
}
function gi(e, t) {
    return null != fi(e, t);
}
function mi(e) {
    return null != yi(e);
}
function yi(e) {
    for (const t of e.views.values())if (t.query._queryParams.loadsAllData()) return t;
    return null;
}
let vi = 1;
class Ci {
    constructor(e){
        this.listenProvider_ = e, this.syncPointTree_ = new yn(null), this.pendingWriteTree_ = {
            visibleWrites: vn.empty(),
            allWrites: [],
            lastWriteId: -1
        }, this.tagToQueryMap = new Map, this.queryToTagMap = new Map;
    }
}
function wi(e, t, n, i, s) {
    return function(e, t, n, i, s) {
        a(i > e.lastWriteId, "Stacking an older write on top of newer ones"), void 0 === s && (s = !0), e.allWrites.push({
            path: t,
            snap: n,
            writeId: i,
            visible: s
        }), s && (e.visibleWrites = Cn(e.visibleWrites, t, n)), e.lastWriteId = i;
    }(e.pendingWriteTree_, t, n, i, s), s ? xi(e, new an({
        fromUser: !0,
        fromServer: !1,
        queryId: null,
        tagged: !1
    }, t, n)) : [];
}
function Ti(e, t, n, i) {
    !function(e, t, n, i) {
        a(i > e.lastWriteId, "Stacking an older merge on top of newer ones"), e.allWrites.push({
            path: t,
            children: n,
            writeId: i,
            visible: !0
        }), e.visibleWrites = wn(e.visibleWrites, t, n), e.lastWriteId = i;
    }(e.pendingWriteTree_, t, n, i);
    const s = yn.fromObject(n);
    return xi(e, new ln({
        fromUser: !0,
        fromServer: !1,
        queryId: null,
        tagged: !1
    }, t, s));
}
function bi(e, t, n = !1) {
    const i = function(e, t) {
        for(let n = 0; n < e.allWrites.length; n++){
            const i = e.allWrites[n];
            if (i.writeId === t) return i;
        }
        return null;
    }(e.pendingWriteTree_, t);
    if (Rn(e.pendingWriteTree_, t)) {
        let t = new yn(null);
        return null != i.snap ? t = t.set(Be(), !0) : pe(i.children, (e)=>{
            t = t.set(new Ue(e), !0);
        }), xi(e, new rn(i.path, t, n));
    }
    return [];
}
function Ei(e, t, n) {
    return xi(e, new an({
        fromUser: !1,
        fromServer: !0,
        queryId: null,
        tagged: !1
    }, t, n));
}
function Ii(e, t, n, i, s = !1) {
    const r = t._path, o = e.syncPointTree_.get(r);
    let a = [];
    if (o && ("default" === t._queryIdentifier || gi(o, t))) {
        const l = di(o, t, n, i);
        0 === o.views.size && (e.syncPointTree_ = e.syncPointTree_.remove(r));
        const h = l.removed;
        if (a = l.events, !s) {
            const n = -1 !== h.findIndex((e)=>e._queryParams.loadsAllData()), s = e.syncPointTree_.findOnPath(r, (e, t)=>mi(t));
            if (n && !s) {
                const t = e.syncPointTree_.subtree(r);
                if (!t.isEmpty()) {
                    const n = function(e) {
                        return e.fold((e, t, n)=>{
                            if (t && mi(t)) return [
                                yi(t)
                            ];
                            {
                                let e = [];
                                return t && (e = _i(t)), pe(n, (t, n)=>{
                                    e = e.concat(n);
                                }), e;
                            }
                        });
                    }(t);
                    for(let t = 0; t < n.length; ++t){
                        const i = n[t], s = i.query, r = Ai(e, i);
                        e.listenProvider_.startListening(Wi(s), Oi(e, s), r.hashFn, r.onComplete);
                    }
                }
            }
            if (!s && h.length > 0 && !i) {
                if (n) {
                    const n = null;
                    e.listenProvider_.stopListening(Wi(t), n);
                } else h.forEach((t)=>{
                    const n = e.queryToTagMap.get(Li(t));
                    e.listenProvider_.stopListening(Wi(t), n);
                });
            }
        }
        !function(e, t) {
            for(let n = 0; n < t.length; ++n){
                const i = t[n];
                if (!i._queryParams.loadsAllData()) {
                    const t = Li(i), n = e.queryToTagMap.get(t);
                    e.queryToTagMap.delete(t), e.tagToQueryMap.delete(n);
                }
            }
        }(e, h);
    }
    return a;
}
function Si(e, t, n, i) {
    const s = Fi(e, i);
    if (null != s) {
        const i = Mi(s), r = i.path, o = i.queryId, a = Ge(r, t);
        return qi(e, r, new an(sn(o), a, n));
    }
    return [];
}
function ki(e, t, n, i = !1) {
    const s = t._path;
    let r = null, o = !1;
    e.syncPointTree_.foreachOnPath(s, (e, t)=>{
        const n = Ge(e, s);
        r = r || pi(t, n), o = o || mi(t);
    });
    let l, h = e.syncPointTree_.get(s);
    if (h ? (o = o || mi(h), r = r || pi(h, Be())) : (h = new li, e.syncPointTree_ = e.syncPointTree_.set(s, h)), null != r) l = !0;
    else {
        l = !1, r = xt.EMPTY_NODE;
        e.syncPointTree_.subtree(s).foreachChild((e, t)=>{
            const n = pi(t, Be());
            n && (r = r.updateImmediateChild(e, n));
        });
    }
    const c = gi(h, t);
    if (!c && !t._queryParams.loadsAllData()) {
        const n = Li(t);
        a(!e.queryToTagMap.has(n), "View does not exist, but we have a tag");
        const i = vi++;
        e.queryToTagMap.set(n, i), e.tagToQueryMap.set(i, n);
    }
    let u = ui(h, t, n, xn(e.pendingWriteTree_, s), r, l);
    if (!c && !o && !i) {
        const n = fi(h, t);
        u = u.concat(function(e, t, n) {
            const i = t._path, s = Oi(e, t), r = Ai(e, n), o = e.listenProvider_.startListening(Wi(t), s, r.hashFn, r.onComplete), l = e.syncPointTree_.subtree(i);
            if (s) a(!mi(l.value), "If we're adding a query, it shouldn't be shadowed");
            else {
                const t = l.fold((e, t, n)=>{
                    if (!$e(e) && t && mi(t)) return [
                        yi(t).query
                    ];
                    {
                        let e = [];
                        return t && (e = e.concat(_i(t).map((e)=>e.query))), pe(n, (t, n)=>{
                            e = e.concat(n);
                        }), e;
                    }
                });
                for(let n = 0; n < t.length; ++n){
                    const i = t[n];
                    e.listenProvider_.stopListening(Wi(i), Oi(e, i));
                }
            }
            return o;
        }(e, t, n));
    }
    return u;
}
function Ni(e, t, n) {
    const i = e.pendingWriteTree_, s = e.syncPointTree_.findOnPath(t, (e, n)=>{
        const i = pi(n, Ge(e, t));
        if (i) return i;
    });
    return Ln(i, t, s, n, !0);
}
function Pi(e, t) {
    const n = t._path;
    let i = null;
    e.syncPointTree_.foreachOnPath(n, (e, t)=>{
        const s = Ge(e, n);
        i = i || pi(t, s);
    });
    let s = e.syncPointTree_.get(n);
    s ? i = i || pi(s, Be()) : (s = new li, e.syncPointTree_ = e.syncPointTree_.set(n, s));
    const r = null != i, o = r ? new hn(i, !0, !1) : null;
    return function(e) {
        return fn(e.viewCache_);
    }(ci(s, t, xn(e.pendingWriteTree_, t._path), r ? o.getNode() : xt.EMPTY_NODE, r));
}
function xi(e, t) {
    return Ri(t, e.syncPointTree_, null, xn(e.pendingWriteTree_, Be()));
}
function Ri(e, t, n, i) {
    if ($e(e.path)) return Di(e, t, n, i);
    {
        const s = t.get(Be());
        null == n && null != s && (n = pi(s, Be()));
        let r = [];
        const o = je(e.path), a = e.operationForChild(o), l = t.children.get(o);
        if (l && a) {
            const e = n ? n.getImmediateChild(o) : null, t = jn(i, o);
            r = r.concat(Ri(a, l, e, t));
        }
        return s && (r = r.concat(hi(s, e, i, n))), r;
    }
}
function Di(e, t, n, i) {
    const s = t.get(Be());
    null == n && null != s && (n = pi(s, Be()));
    let r = [];
    return t.children.inorderTraversal((t, s)=>{
        const o = n ? n.getImmediateChild(t) : null, a = jn(i, t), l = e.operationForChild(t);
        l && (r = r.concat(Di(l, s, o, a)));
    }), s && (r = r.concat(hi(s, e, i, n))), r;
}
function Ai(e, t) {
    const n = t.query, i = Oi(e, n);
    return {
        hashFn: ()=>{
            const e = function(e) {
                return e.viewCache_.serverCache.getNode();
            }(t) || xt.EMPTY_NODE;
            return e.hash();
        },
        onComplete: (t)=>{
            if ("ok" === t) return i ? function(e, t, n) {
                const i = Fi(e, n);
                if (i) {
                    const n = Mi(i), s = n.path, r = n.queryId, o = Ge(s, t);
                    return qi(e, s, new on(sn(r), o));
                }
                return [];
            }(e, n._path, i) : function(e, t) {
                return xi(e, new on({
                    fromUser: !1,
                    fromServer: !0,
                    queryId: null,
                    tagged: !1
                }, t));
            }(e, n._path);
            {
                const i = function(e, t) {
                    let n = "Unknown Error";
                    "too_big" === e ? n = "The data requested exceeds the maximum size that can be accessed with a single request." : "permission_denied" === e ? n = "Client doesn't have permission to access the desired data." : "unavailable" === e && (n = "The service is unavailable");
                    const i = new Error(e + " at " + t._path.toString() + ": " + n);
                    return i.code = e.toUpperCase(), i;
                }(t, n);
                return Ii(e, n, null, i);
            }
        }
    };
}
function Oi(e, t) {
    const n = Li(t);
    return e.queryToTagMap.get(n);
}
function Li(e) {
    return e._path.toString() + "$" + e._queryIdentifier;
}
function Fi(e, t) {
    return e.tagToQueryMap.get(t);
}
function Mi(e) {
    const t = e.indexOf("$");
    return a(-1 !== t && t < e.length - 1, "Bad queryKey."), {
        queryId: e.substr(t + 1),
        path: new Ue(e.substr(0, t))
    };
}
function qi(e, t, n) {
    const i = e.syncPointTree_.get(t);
    a(i, "Missing sync point for query tag that we're tracking");
    return hi(i, n, xn(e.pendingWriteTree_, t), null);
}
function Wi(e) {
    return e._queryParams.loadsAllData() && !e._queryParams.isDefault() ? new (a(ai, "Reference.ts has not been loaded"), ai)(e._repo, e._path) : e;
}
class Ui {
    constructor(e){
        this.node_ = e;
    }
    getImmediateChild(e) {
        const t = this.node_.getImmediateChild(e);
        return new Ui(t);
    }
    node() {
        return this.node_;
    }
}
class Bi {
    constructor(e, t){
        this.syncTree_ = e, this.path_ = t;
    }
    getImmediateChild(e) {
        const t = Qe(this.path_, e);
        return new Bi(this.syncTree_, t);
    }
    node() {
        return Ni(this.syncTree_, this.path_);
    }
}
const ji = function(e, t, n) {
    return e && "object" == typeof e ? (a(".sv" in e, "Unexpected leaf node or priority contents"), "string" == typeof e[".sv"] ? Hi(e[".sv"], t, n) : "object" == typeof e[".sv"] ? Vi(e[".sv"], t) : void a(!1, "Unexpected server value: " + JSON.stringify(e, null, 2))) : e;
}, Hi = function(e, t, n) {
    if ("timestamp" === e) return n.timestamp;
    a(!1, "Unexpected server value: " + e);
}, Vi = function(e, t, n) {
    e.hasOwnProperty("increment") || a(!1, "Unexpected server value: " + JSON.stringify(e, null, 2));
    const i = e.increment;
    "number" != typeof i && a(!1, "Unexpected increment value: " + i);
    const s = t.node();
    if (a(null != s, "Expected ChildrenNode.EMPTY_NODE for nulls"), !s.isLeafNode()) return i;
    const r = s.getValue();
    return "number" != typeof r ? i : r + i;
}, zi = function(e, t, n, i) {
    return Ki(t, new Bi(n, e), i);
}, Yi = function(e, t, n) {
    return Ki(e, new Ui(t), n);
};
function Ki(e, t, n) {
    const i = e.getPriority().val(), s = ji(i, t.getImmediateChild(".priority"), n);
    let r;
    if (e.isLeafNode()) {
        const i = e, r = ji(i.getValue(), t, n);
        return r !== i.getValue() || s !== i.getPriority().val() ? new wt(r, Dt(s)) : e;
    }
    {
        const i = e;
        return r = i, s !== i.getPriority().val() && (r = r.updatePriority(new wt(s))), i.forEachChild(Tt, (e, i)=>{
            const s = Ki(i, t.getImmediateChild(e), n);
            s !== i && (r = r.updateImmediateChild(e, s));
        }), r;
    }
}
class Qi {
    constructor(e = "", t = null, n = {
        children: {},
        childCount: 0
    }){
        this.name = e, this.parent = t, this.node = n;
    }
}
function $i(e, t) {
    let n = t instanceof Ue ? t : new Ue(t), i = e, s = je(n);
    for(; null !== s;){
        const e = k(i.node.children, s) || {
            children: {},
            childCount: 0
        };
        i = new Qi(s, i, e), n = Ve(n), s = je(n);
    }
    return i;
}
function Gi(e) {
    return e.node.value;
}
function Ji(e, t) {
    e.node.value = t, ns(e);
}
function Xi(e) {
    return e.node.childCount > 0;
}
function Zi(e, t) {
    pe(e.node.children, (n, i)=>{
        t(new Qi(n, e, i));
    });
}
function es(e, t, n, i) {
    n && !i && t(e), Zi(e, (e)=>{
        es(e, t, !0, i);
    }), n && i && t(e);
}
function ts(e) {
    return new Ue(null === e.parent ? e.name : ts(e.parent) + "/" + e.name);
}
function ns(e) {
    null !== e.parent && function(e, t, n) {
        const i = function(e) {
            return void 0 === Gi(e) && !Xi(e);
        }(n), s = S(e.node.children, t);
        i && s ? (delete e.node.children[t], e.node.childCount--, ns(e)) : i || s || (e.node.children[t] = n.node, e.node.childCount++, ns(e));
    }(e.parent, e.name, e);
}
const is = /[\[\].#$\/\u0000-\u001F\u007F]/, ss = /[\[\].#$\u0000-\u001F\u007F]/, rs = function(e) {
    return "string" == typeof e && 0 !== e.length && !is.test(e);
}, os = function(e) {
    return "string" == typeof e && 0 !== e.length && !ss.test(e);
}, as = function(e) {
    return null === e || "string" == typeof e || "number" == typeof e && !oe(e) || e && "object" == typeof e && S(e, ".sv");
}, ls = function(e, t, n, i) {
    i && void 0 === t || hs(R(e, "value"), t, n);
}, hs = function(e, t, n) {
    const i = n instanceof Ue ? new et(n, e) : n;
    if (void 0 === t) throw new Error(e + "contains undefined " + nt(i));
    if ("function" == typeof t) throw new Error(e + "contains a function " + nt(i) + " with contents = " + t.toString());
    if (oe(t)) throw new Error(e + "contains " + t.toString() + " " + nt(i));
    if ("string" == typeof t && t.length > 10485760 / 3 && D(t) > 10485760) throw new Error(e + "contains a string greater than 10485760 utf8 bytes " + nt(i) + " ('" + t.substring(0, 50) + "...')");
    if (t && "object" == typeof t) {
        let n = !1, s = !1;
        if (pe(t, (t, r)=>{
            if (".value" === t) n = !0;
            else if (".priority" !== t && ".sv" !== t && (s = !0, !rs(t))) throw new Error(e + " contains an invalid key (" + t + ") " + nt(i) + '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');
            !function(e, t) {
                e.parts_.length > 0 && (e.byteLength_ += 1), e.parts_.push(t), e.byteLength_ += D(t), tt(e);
            }(i, t), hs(e, r, i), function(e) {
                const t = e.parts_.pop();
                e.byteLength_ -= D(t), e.parts_.length > 0 && (e.byteLength_ -= 1);
            }(i);
        }), n && s) throw new Error(e + ' contains ".value" child ' + nt(i) + " in addition to actual children.");
    }
}, cs = function(e, t, n, i) {
    if (i && void 0 === t) return;
    const s = R(e, "values");
    if (!t || "object" != typeof t || Array.isArray(t)) throw new Error(s + " must be an object containing the children to replace.");
    const r = [];
    pe(t, (e, t)=>{
        const i = new Ue(e);
        if (hs(s, t, Qe(n, i)), ".priority" === ze(i) && !as(t)) throw new Error(s + "contains an invalid value for '" + i.toString() + "', which must be a valid Firebase priority (a string, finite number, server value, or null).");
        r.push(i);
    }), function(e, t) {
        let n, i;
        for(n = 0; n < t.length; n++){
            i = t[n];
            const s = Ye(i);
            for(let t = 0; t < s.length; t++)if (".priority" === s[t] && t === s.length - 1) ;
            else if (!rs(s[t])) throw new Error(e + "contains an invalid key (" + s[t] + ") in path " + i.toString() + '. Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');
        }
        t.sort(Je);
        let s = null;
        for(n = 0; n < t.length; n++){
            if (i = t[n], null !== s && Ze(s, i)) throw new Error(e + "contains a path " + s.toString() + " that is ancestor of another path " + i.toString());
            s = i;
        }
    }(s, r);
}, us = function(e, t, n) {
    if (!n || void 0 !== t) {
        if (oe(t)) throw new Error(R(e, "priority") + "is " + t.toString() + ", but must be a valid Firebase priority (a string, finite number, server value, or null).");
        if (!as(t)) throw new Error(R(e, "priority") + "must be a valid Firebase priority (a string, finite number, server value, or null).");
    }
}, ds = function(e, t, n, i) {
    if (!(i && void 0 === n || rs(n))) throw new Error(R(e, t) + 'was an invalid key = "' + n + '".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").');
}, _s = function(e, t, n, i) {
    if (!(i && void 0 === n || os(n))) throw new Error(R(e, t) + 'was an invalid path = "' + n + '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"');
}, ps = function(e, t) {
    if (".info" === je(t)) throw new Error(e + " failed = Can't modify data under /.info/");
}, fs = function(e, t) {
    const n = t.path.toString();
    if ("string" != typeof t.repoInfo.host || 0 === t.repoInfo.host.length || !rs(t.repoInfo.namespace) && "localhost" !== t.repoInfo.host.split(":")[0] || 0 !== n.length && !function(e) {
        return e && (e = e.replace(/^\/*\.info(\/|$)/, "/")), os(e);
    }(n)) throw new Error(R(e, "url") + 'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".');
};
class gs {
    constructor(){
        this.eventLists_ = [], this.recursionDepth_ = 0;
    }
}
function ms(e, t) {
    let n = null;
    for(let i = 0; i < t.length; i++){
        const s = t[i], r = s.getPath();
        null === n || Xe(r, n.path) || (e.eventLists_.push(n), n = null), null === n && (n = {
            events: [],
            path: r
        }), n.events.push(s);
    }
    n && e.eventLists_.push(n);
}
function ys(e, t, n) {
    ms(e, n), Cs(e, (e)=>Xe(e, t));
}
function vs(e, t, n) {
    ms(e, n), Cs(e, (e)=>Ze(e, t) || Ze(t, e));
}
function Cs(e, t) {
    e.recursionDepth_++;
    let n = !0;
    for(let i = 0; i < e.eventLists_.length; i++){
        const s = e.eventLists_[i];
        if (s) t(s.path) ? (ws(e.eventLists_[i]), e.eventLists_[i] = null) : n = !1;
    }
    n && (e.eventLists_ = []), e.recursionDepth_--;
}
function ws(e) {
    for(let t = 0; t < e.events.length; t++){
        const n = e.events[t];
        if (null !== n) {
            e.events[t] = null;
            const i = n.getEventRunner();
            X && te("event: " + n.toString()), ye(i);
        }
    }
}
class Ts {
    constructor(e, t, n, i){
        this.repoInfo_ = e, this.forceRestClient_ = t, this.authTokenProvider_ = n, this.appCheckProvider_ = i, this.dataUpdateCount = 0, this.statsListener_ = null, this.eventQueue_ = new gs, this.nextWriteId_ = 1, this.interceptServerDataCallback_ = null, this.onDisconnect_ = Gt(), this.transactionQueueTree_ = new Qi, this.persistentConnection_ = null, this.key = this.repoInfo_.toURLString();
    }
    toString() {
        return (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host;
    }
}
function bs(e, t, n) {
    if (e.stats_ = Pe(e.repoInfo_), e.forceRestClient_ || ("object" == typeof window && window.navigator && window.navigator.userAgent || "").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0) e.server_ = new Qt(e.repoInfo_, (t, n, i, s)=>{
        Ss(e, t, n, i, s);
    }, e.authTokenProvider_, e.appCheckProvider_), setTimeout(()=>ks(e, !0), 0);
    else {
        if (null != n) {
            if ("object" != typeof n) throw new Error("Only objects are supported for option databaseAuthVariableOverride");
            try {
                E(n);
            } catch (e) {
                throw new Error("Invalid authOverride provided: " + e);
            }
        }
        e.persistentConnection_ = new st(e.repoInfo_, t, (t, n, i, s)=>{
            Ss(e, t, n, i, s);
        }, (t)=>{
            ks(e, t);
        }, (t)=>{
            !function(e, t) {
                pe(t, (t, n)=>{
                    Ns(e, t, n);
                });
            }(e, t);
        }, e.authTokenProvider_, e.appCheckProvider_, n), e.server_ = e.persistentConnection_;
    }
    e.authTokenProvider_.addTokenChangeListener((t)=>{
        e.server_.refreshAuthToken(t);
    }), e.appCheckProvider_.addTokenChangeListener((t)=>{
        e.server_.refreshAppCheckToken(t.token);
    }), e.statsReporter_ = function(e, t) {
        const n = e.toString();
        return Ne[n] || (Ne[n] = t()), Ne[n];
    }(e.repoInfo_, ()=>new tn(e.stats_, e.server_)), e.infoData_ = new $t, e.infoSyncTree_ = new Ci({
        startListening: (t, n, i, s)=>{
            let r = [];
            const o = e.infoData_.getNode(t._path);
            return o.isEmpty() || (r = Ei(e.infoSyncTree_, t._path, o), setTimeout(()=>{
                s("ok");
            }, 0)), r;
        },
        stopListening: ()=>{}
    }), Ns(e, "connected", !1), e.serverSyncTree_ = new Ci({
        startListening: (t, n, i, s)=>(e.server_.listen(t, i, n, (n, i)=>{
                const r = s(n, i);
                vs(e.eventQueue_, t._path, r);
            }), []),
        stopListening: (t, n)=>{
            e.server_.unlisten(t, n);
        }
    });
}
function Es(e) {
    const t = e.infoData_.getNode(new Ue(".info/serverTimeOffset")).val() || 0;
    return (new Date).getTime() + t;
}
function Is(e) {
    var t;
    return (t = t = {
        timestamp: Es(e)
    }).timestamp = t.timestamp || (new Date).getTime(), t;
}
function Ss(e, t, n, i, s) {
    e.dataUpdateCount++;
    const r = new Ue(t);
    n = e.interceptServerDataCallback_ ? e.interceptServerDataCallback_(t, n) : n;
    let o = [];
    if (s) {
        if (i) {
            const t = P(n, (e)=>Dt(e));
            o = function(e, t, n, i) {
                const s = Fi(e, i);
                if (s) {
                    const i = Mi(s), r = i.path, o = i.queryId, a = Ge(r, t), l = yn.fromObject(n);
                    return qi(e, r, new ln(sn(o), a, l));
                }
                return [];
            }(e.serverSyncTree_, r, t, s);
        } else {
            const t = Dt(n);
            o = Si(e.serverSyncTree_, r, t, s);
        }
    } else if (i) {
        const t = P(n, (e)=>Dt(e));
        o = function(e, t, n) {
            const i = yn.fromObject(n);
            return xi(e, new ln({
                fromUser: !1,
                fromServer: !0,
                queryId: null,
                tagged: !1
            }, t, i));
        }(e.serverSyncTree_, r, t);
    } else {
        const t = Dt(n);
        o = Ei(e.serverSyncTree_, r, t);
    }
    let a = r;
    o.length > 0 && (a = Ws(e, r)), vs(e.eventQueue_, a, o);
}
function ks(e, t) {
    Ns(e, "connected", t), !1 === t && function(e) {
        Ls(e, "onDisconnectEvents");
        const t = Is(e), n = Gt();
        Zt(e.onDisconnect_, Be(), (i, s)=>{
            const r = zi(i, s, e.serverSyncTree_, t);
            Jt(n, i, r);
        });
        let i = [];
        Zt(n, Be(), (t, n)=>{
            i = i.concat(Ei(e.serverSyncTree_, t, n));
            const s = Vs(e, t);
            Ws(e, s);
        }), e.onDisconnect_ = Gt(), vs(e.eventQueue_, Be(), i);
    }(e);
}
function Ns(e, t, n) {
    const i = new Ue("/.info/" + t), s = Dt(n);
    e.infoData_.updateSnapshot(i, s);
    const r = Ei(e.infoSyncTree_, i, s);
    vs(e.eventQueue_, i, r);
}
function Ps(e) {
    return e.nextWriteId_++;
}
function xs(e, t, n, i, s) {
    Ls(e, "set", {
        path: t.toString(),
        value: n,
        priority: i
    });
    const r = Is(e), o = Dt(n, i), a = Ni(e.serverSyncTree_, t), l = Yi(o, a, r), h = Ps(e), c = wi(e.serverSyncTree_, t, l, h, !0);
    ms(e.eventQueue_, c), e.server_.put(t.toString(), o.val(!0), (n, i)=>{
        const r = "ok" === n;
        r || re("set at " + t + " failed: " + n);
        const o = bi(e.serverSyncTree_, h, !r);
        vs(e.eventQueue_, t, o), Fs(e, s, n, i);
    });
    const u = Vs(e, t);
    Ws(e, u), vs(e.eventQueue_, u, []);
}
function Rs(e, t, n) {
    e.server_.onDisconnectCancel(t.toString(), (i, s)=>{
        "ok" === i && Xt(e.onDisconnect_, t), Fs(e, n, i, s);
    });
}
function Ds(e, t, n, i) {
    const s = Dt(n);
    e.server_.onDisconnectPut(t.toString(), s.val(!0), (n, r)=>{
        "ok" === n && Jt(e.onDisconnect_, t, s), Fs(e, i, n, r);
    });
}
function As(e, t, n) {
    let i;
    i = ".info" === je(t._path) ? Ii(e.infoSyncTree_, t, n) : Ii(e.serverSyncTree_, t, n), ys(e.eventQueue_, t._path, i);
}
function Os(e) {
    e.persistentConnection_ && e.persistentConnection_.interrupt("repo_interrupt");
}
function Ls(e, ...t) {
    let n = "";
    e.persistentConnection_ && (n = e.persistentConnection_.id + ":"), te(n, ...t);
}
function Fs(e, t, n, i) {
    t && ye(()=>{
        if ("ok" === n) t(null);
        else {
            const e = (n || "error").toUpperCase();
            let s = e;
            i && (s += ": " + i);
            const r = new Error(s);
            r.code = e, t(r);
        }
    });
}
function Ms(e, t, n) {
    return Ni(e.serverSyncTree_, t, n) || xt.EMPTY_NODE;
}
function qs(e, t = e.transactionQueueTree_) {
    if (t || Hs(e, t), Gi(t)) {
        const n = Bs(e, t);
        a(n.length > 0, "Sending zero length transaction queue");
        n.every((e)=>0 === e.status) && function(e, t, n) {
            const i = n.map((e)=>e.currentWriteId), s = Ms(e, t, i);
            let r = s;
            const o = s.hash();
            for(let e = 0; e < n.length; e++){
                const i = n[e];
                a(0 === i.status, "tryToSendTransactionQueue_: items in queue should all be run."), i.status = 1, i.retryCount++;
                const s = Ge(t, i.path);
                r = r.updateChild(s, i.currentOutputSnapshotRaw);
            }
            const l = r.val(!0), h = t;
            e.server_.put(h.toString(), l, (i)=>{
                Ls(e, "transaction put response", {
                    path: h.toString(),
                    status: i
                });
                let s = [];
                if ("ok" === i) {
                    const i = [];
                    for(let t = 0; t < n.length; t++)n[t].status = 2, s = s.concat(bi(e.serverSyncTree_, n[t].currentWriteId)), n[t].onComplete && i.push(()=>n[t].onComplete(null, !0, n[t].currentOutputSnapshotResolved)), n[t].unwatcher();
                    Hs(e, $i(e.transactionQueueTree_, t)), qs(e, e.transactionQueueTree_), vs(e.eventQueue_, t, s);
                    for(let e = 0; e < i.length; e++)ye(i[e]);
                } else {
                    if ("datastale" === i) for(let e = 0; e < n.length; e++)3 === n[e].status ? n[e].status = 4 : n[e].status = 0;
                    else {
                        re("transaction at " + h.toString() + " failed: " + i);
                        for(let e = 0; e < n.length; e++)n[e].status = 4, n[e].abortReason = i;
                    }
                    Ws(e, t);
                }
            }, o);
        }(e, ts(t), n);
    } else Xi(t) && Zi(t, (t)=>{
        qs(e, t);
    });
}
function Ws(e, t) {
    const n = Us(e, t), i = ts(n);
    return function(e, t, n) {
        if (0 === t.length) return;
        const i = [];
        let s = [];
        const r = t.filter((e)=>0 === e.status).map((e)=>e.currentWriteId);
        for(let l = 0; l < t.length; l++){
            const h = t[l], c = Ge(n, h.path);
            let u, d = !1;
            if (a(null !== c, "rerunTransactionsUnderNode_: relativePath should not be null."), 4 === h.status) d = !0, u = h.abortReason, s = s.concat(bi(e.serverSyncTree_, h.currentWriteId, !0));
            else if (0 === h.status) {
                if (h.retryCount >= 25) d = !0, u = "maxretry", s = s.concat(bi(e.serverSyncTree_, h.currentWriteId, !0));
                else {
                    const n = Ms(e, h.path, r);
                    h.currentInputSnapshot = n;
                    const i = t[l].update(n.val());
                    if (void 0 !== i) {
                        hs("transaction failed: Data returned ", i, h.path);
                        let t = Dt(i);
                        "object" == typeof i && null != i && S(i, ".priority") || (t = t.updatePriority(n.getPriority()));
                        const o = h.currentWriteId, a = Is(e), l = Yi(t, n, a);
                        h.currentOutputSnapshotRaw = t, h.currentOutputSnapshotResolved = l, h.currentWriteId = Ps(e), r.splice(r.indexOf(o), 1), s = s.concat(wi(e.serverSyncTree_, h.path, l, h.currentWriteId, h.applyLocally)), s = s.concat(bi(e.serverSyncTree_, o, !0));
                    } else d = !0, u = "nodata", s = s.concat(bi(e.serverSyncTree_, h.currentWriteId, !0));
                }
            }
            vs(e.eventQueue_, n, s), s = [], d && (t[l].status = 2, o = t[l].unwatcher, setTimeout(o, Math.floor(0)), t[l].onComplete && ("nodata" === u ? i.push(()=>t[l].onComplete(null, !1, t[l].currentInputSnapshot)) : i.push(()=>t[l].onComplete(new Error(u), !1, null))));
        }
        var o;
        Hs(e, e.transactionQueueTree_);
        for(let e = 0; e < i.length; e++)ye(i[e]);
        qs(e, e.transactionQueueTree_);
    }(e, Bs(e, n), i), i;
}
function Us(e, t) {
    let n, i = e.transactionQueueTree_;
    for(n = je(t); null !== n && void 0 === Gi(i);)i = $i(i, n), n = je(t = Ve(t));
    return i;
}
function Bs(e, t) {
    const n = [];
    return js(e, t, n), n.sort((e, t)=>e.order - t.order), n;
}
function js(e, t, n) {
    const i = Gi(t);
    if (i) for(let e = 0; e < i.length; e++)n.push(i[e]);
    Zi(t, (t)=>{
        js(e, t, n);
    });
}
function Hs(e, t) {
    const n = Gi(t);
    if (n) {
        let e = 0;
        for(let t = 0; t < n.length; t++)2 !== n[t].status && (n[e] = n[t], e++);
        n.length = e, Ji(t, n.length > 0 ? n : void 0);
    }
    Zi(t, (t)=>{
        Hs(e, t);
    });
}
function Vs(e, t) {
    const n = ts(Us(e, t)), i = $i(e.transactionQueueTree_, t);
    return function(e, t, n) {
        let i = n ? e : e.parent;
        for(; null !== i;){
            if (t(i)) return !0;
            i = i.parent;
        }
    }(i, (t)=>{
        zs(e, t);
    }), zs(e, i), es(i, (t)=>{
        zs(e, t);
    }), n;
}
function zs(e, t) {
    const n = Gi(t);
    if (n) {
        const i = [];
        let s = [], r = -1;
        for(let t = 0; t < n.length; t++)3 === n[t].status || (1 === n[t].status ? (a(r === t - 1, "All SENT items should be at beginning of queue."), r = t, n[t].status = 3, n[t].abortReason = "set") : (a(0 === n[t].status, "Unexpected transaction status in abort"), n[t].unwatcher(), s = s.concat(bi(e.serverSyncTree_, n[t].currentWriteId, !0)), n[t].onComplete && i.push(n[t].onComplete.bind(null, new Error("set"), !1, null))));
        -1 === r ? Ji(t, void 0) : n.length = r + 1, vs(e.eventQueue_, ts(t), s);
        for(let e = 0; e < i.length; e++)ye(i[e]);
    }
}
const Ys = function(e, t) {
    const n = Ks(e), i = n.namespace;
    "firebase.com" === n.domain && se(n.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead"), i && "undefined" !== i || "localhost" === n.domain || se("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com"), n.secure || "undefined" != typeof window && window.location && window.location.protocol && -1 !== window.location.protocol.indexOf("https:") && re("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
    const s = "ws" === n.scheme || "wss" === n.scheme;
    return {
        repoInfo: new Ee(n.host, n.secure, i, s, t, "", i !== n.subdomain),
        path: new Ue(n.pathString)
    };
}, Ks = function(e) {
    let t = "", n = "", i = "", s = "", r = "", o = !0, a = "https", l = 443;
    if ("string" == typeof e) {
        let h = e.indexOf("//");
        h >= 0 && (a = e.substring(0, h - 1), e = e.substring(h + 2));
        let c = e.indexOf("/");
        -1 === c && (c = e.length);
        let u = e.indexOf("?");
        -1 === u && (u = e.length), t = e.substring(0, Math.min(c, u)), c < u && (s = function(e) {
            let t = "";
            const n = e.split("/");
            for(let e = 0; e < n.length; e++)if (n[e].length > 0) {
                let i = n[e];
                try {
                    i = decodeURIComponent(i.replace(/\+/g, " "));
                } catch (e) {}
                t += "/" + i;
            }
            return t;
        }(e.substring(c, u)));
        const d = function(e) {
            const t = {};
            "?" === e.charAt(0) && (e = e.substring(1));
            for (const n of e.split("&")){
                if (0 === n.length) continue;
                const i = n.split("=");
                2 === i.length ? t[decodeURIComponent(i[0])] = decodeURIComponent(i[1]) : re(`Invalid query segment '${n}' in query '${e}'`);
            }
            return t;
        }(e.substring(Math.min(e.length, u)));
        h = t.indexOf(":"), h >= 0 ? (o = "https" === a || "wss" === a, l = parseInt(t.substring(h + 1), 10)) : h = t.length;
        const _ = t.slice(0, h);
        if ("localhost" === _.toLowerCase()) n = "localhost";
        else if (_.split(".").length <= 2) n = _;
        else {
            const e = t.indexOf(".");
            i = t.substring(0, e).toLowerCase(), n = t.substring(e + 1), r = i;
        }
        "ns" in d && (r = d.ns);
    }
    return {
        host: t,
        port: l,
        domain: n,
        subdomain: i,
        secure: o,
        scheme: a,
        pathString: s,
        namespace: r
    };
}, Qs = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz", $s = function() {
    let e = 0;
    const t = [];
    return function(n) {
        const i = n === e;
        let s;
        e = n;
        const r = new Array(8);
        for(s = 7; s >= 0; s--)r[s] = Qs.charAt(n % 64), n = Math.floor(n / 64);
        a(0 === n, "Cannot push at time == 0");
        let o = r.join("");
        if (i) {
            for(s = 11; s >= 0 && 63 === t[s]; s--)t[s] = 0;
            t[s]++;
        } else for(s = 0; s < 12; s++)t[s] = Math.floor(64 * Math.random());
        for(s = 0; s < 12; s++)o += Qs.charAt(t[s]);
        return a(20 === o.length, "nextPushId: Length should be 20."), o;
    };
}();
class Gs {
    constructor(e, t, n, i){
        this.eventType = e, this.eventRegistration = t, this.snapshot = n, this.prevName = i;
    }
    getPath() {
        const e = this.snapshot.ref;
        return "value" === this.eventType ? e._path : e.parent._path;
    }
    getEventType() {
        return this.eventType;
    }
    getEventRunner() {
        return this.eventRegistration.getEventRunner(this);
    }
    toString() {
        return this.getPath().toString() + ":" + this.eventType + ":" + E(this.snapshot.exportVal());
    }
}
class Js {
    constructor(e, t, n){
        this.eventRegistration = e, this.error = t, this.path = n;
    }
    getPath() {
        return this.path;
    }
    getEventType() {
        return "cancel";
    }
    getEventRunner() {
        return this.eventRegistration.getEventRunner(this);
    }
    toString() {
        return this.path.toString() + ":cancel";
    }
}
class Xs {
    constructor(e, t){
        this.snapshotCallback = e, this.cancelCallback = t;
    }
    onValue(e, t) {
        this.snapshotCallback.call(null, e, t);
    }
    onCancel(e) {
        return a(this.hasCancelCallback, "Raising a cancel event on a listener with no cancel callback"), this.cancelCallback.call(null, e);
    }
    get hasCancelCallback() {
        return !!this.cancelCallback;
    }
    matches(e) {
        return this.snapshotCallback === e.snapshotCallback || void 0 !== this.snapshotCallback.userCallback && this.snapshotCallback.userCallback === e.snapshotCallback.userCallback && this.snapshotCallback.context === e.snapshotCallback.context;
    }
}
class Zs {
    constructor(e, t){
        this._repo = e, this._path = t;
    }
    cancel() {
        const e = new C;
        return Rs(this._repo, this._path, e.wrapCallback(()=>{})), e.promise;
    }
    remove() {
        ps("OnDisconnect.remove", this._path);
        const e = new C;
        return Ds(this._repo, this._path, null, e.wrapCallback(()=>{})), e.promise;
    }
    set(e) {
        ps("OnDisconnect.set", this._path), ls("OnDisconnect.set", e, this._path, !1);
        const t = new C;
        return Ds(this._repo, this._path, e, t.wrapCallback(()=>{})), t.promise;
    }
    setWithPriority(e, t) {
        ps("OnDisconnect.setWithPriority", this._path), ls("OnDisconnect.setWithPriority", e, this._path, !1), us("OnDisconnect.setWithPriority", t, !1);
        const n = new C;
        return function(e, t, n, i, s) {
            const r = Dt(n, i);
            e.server_.onDisconnectPut(t.toString(), r.val(!0), (n, i)=>{
                "ok" === n && Jt(e.onDisconnect_, t, r), Fs(0, s, n, i);
            });
        }(this._repo, this._path, e, t, n.wrapCallback(()=>{})), n.promise;
    }
    update(e) {
        ps("OnDisconnect.update", this._path), cs("OnDisconnect.update", e, this._path, !1);
        const t = new C;
        return function(e, t, n, i) {
            if (N(n)) return te("onDisconnect().update() called with empty data.  Don't do anything."), void Fs(0, i, "ok", void 0);
            e.server_.onDisconnectMerge(t.toString(), n, (s, r)=>{
                "ok" === s && pe(n, (n, i)=>{
                    const s = Dt(i);
                    Jt(e.onDisconnect_, Qe(t, n), s);
                }), Fs(0, i, s, r);
            });
        }(this._repo, this._path, e, t.wrapCallback(()=>{})), t.promise;
    }
}
class er {
    constructor(e, t, n, i){
        this._repo = e, this._path = t, this._queryParams = n, this._orderByCalled = i;
    }
    get key() {
        return $e(this._path) ? null : ze(this._path);
    }
    get ref() {
        return new sr(this._repo, this._path);
    }
    get _queryIdentifier() {
        const e = Kt(this._queryParams), t = de(e);
        return "{}" === t ? "default" : t;
    }
    get _queryObject() {
        return Kt(this._queryParams);
    }
    isEqual(e) {
        if (!((e = A(e)) instanceof er)) return !1;
        const t = this._repo === e._repo, n = Xe(this._path, e._path), i = this._queryIdentifier === e._queryIdentifier;
        return t && n && i;
    }
    toJSON() {
        return this.toString();
    }
    toString() {
        return this._repo.toString() + function(e) {
            let t = "";
            for(let n = e.pieceNum_; n < e.pieces_.length; n++)"" !== e.pieces_[n] && (t += "/" + encodeURIComponent(String(e.pieces_[n])));
            return t || "/";
        }(this._path);
    }
}
function tr(e, t) {
    if (!0 === e._orderByCalled) throw new Error(t + ": You can't combine multiple orderBy calls.");
}
function nr(e) {
    let t = null, n = null;
    if (e.hasStart() && (t = e.getIndexStartValue()), e.hasEnd() && (n = e.getIndexEndValue()), e.getIndex() === ht) {
        const i = "Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().", s = "Query: When ordering by key, the argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() must be a string.";
        if (e.hasStart()) {
            if (e.getIndexStartName() !== ae) throw new Error(i);
            if ("string" != typeof t) throw new Error(s);
        }
        if (e.hasEnd()) {
            if (e.getIndexEndName() !== le) throw new Error(i);
            if ("string" != typeof n) throw new Error(s);
        }
    } else if (e.getIndex() === Tt) {
        if (null != t && !as(t) || null != n && !as(n)) throw new Error("Query: When ordering by priority, the first argument passed to startAt(), startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value (null, a number, or a string).");
    } else if (a(e.getIndex() instanceof At || e.getIndex() === Ot, "unknown index type."), null != t && "object" == typeof t || null != n && "object" == typeof n) throw new Error("Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() cannot be an object.");
}
function ir(e) {
    if (e.hasStart() && e.hasEnd() && e.hasLimit() && !e.hasAnchoredLimit()) throw new Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use limitToFirst() or limitToLast() instead.");
}
class sr extends er {
    constructor(e, t){
        super(e, t, new jt, !1);
    }
    get parent() {
        const e = Ke(this._path);
        return null === e ? null : new sr(this._repo, e);
    }
    get root() {
        let e = this;
        for(; null !== e.parent;)e = e.parent;
        return e;
    }
}
class rr {
    constructor(e, t, n){
        this._node = e, this.ref = t, this._index = n;
    }
    get priority() {
        return this._node.getPriority().val();
    }
    get key() {
        return this.ref.key;
    }
    get size() {
        return this._node.numChildren();
    }
    child(e) {
        const t = new Ue(e), n = lr(this.ref, e);
        return new rr(this._node.getChild(t), n, Tt);
    }
    exists() {
        return !this._node.isEmpty();
    }
    exportVal() {
        return this._node.val(!0);
    }
    forEach(e) {
        if (this._node.isLeafNode()) return !1;
        return !!this._node.forEachChild(this._index, (t, n)=>e(new rr(n, lr(this.ref, t), Tt)));
    }
    hasChild(e) {
        const t = new Ue(e);
        return !this._node.getChild(t).isEmpty();
    }
    hasChildren() {
        return !this._node.isLeafNode() && !this._node.isEmpty();
    }
    toJSON() {
        return this.exportVal();
    }
    val() {
        return this._node.val();
    }
}
function or(e, t) {
    return (e = A(e))._checkNotDeleted("ref"), void 0 !== t ? lr(e._root, t) : e._root;
}
function ar(e, t) {
    (e = A(e))._checkNotDeleted("refFromURL");
    const n = Ys(t, e._repo.repoInfo_.nodeAdmin);
    fs("refFromURL", n);
    const i = n.repoInfo;
    return e._repo.repoInfo_.isCustomHost() || i.host === e._repo.repoInfo_.host || se("refFromURL: Host name does not match the current database: (found " + i.host + " but expected " + e._repo.repoInfo_.host + ")"), or(e, n.path.toString());
}
function lr(e, t) {
    var n, i, s, r;
    return null === je((e = A(e))._path) ? (n = "child", i = "path", r = !1, (s = t) && (s = s.replace(/^\/*\.info(\/|$)/, "/")), _s(n, i, s, r)) : _s("child", "path", t, !1), new sr(e._repo, Qe(e._path, t));
}
function hr(e) {
    return e = A(e), new Zs(e._repo, e._path);
}
function cr(e, t) {
    e = A(e), ps("push", e._path), ls("push", t, e._path, !0);
    const n = Es(e._repo), i = $s(n), s = lr(e, i), r = lr(e, i);
    let o;
    return o = null != t ? dr(r, t).then(()=>r) : Promise.resolve(r), s.then = o.then.bind(o), s.catch = o.then.bind(o, void 0), s;
}
function ur(e) {
    return ps("remove", e._path), dr(e, null);
}
function dr(e, t) {
    e = A(e), ps("set", e._path), ls("set", t, e._path, !1);
    const n = new C;
    return xs(e._repo, e._path, t, null, n.wrapCallback(()=>{})), n.promise;
}
function _r(e, t) {
    e = A(e), ps("setPriority", e._path), us("setPriority", t, !1);
    const n = new C;
    return xs(e._repo, Qe(e._path, ".priority"), t, null, n.wrapCallback(()=>{})), n.promise;
}
function pr(e, t, n) {
    if (ps("setWithPriority", e._path), ls("setWithPriority", t, e._path, !1), us("setWithPriority", n, !1), ".length" === e.key || ".keys" === e.key) throw "setWithPriority failed: " + e.key + " is a read-only object.";
    const i = new C;
    return xs(e._repo, e._path, t, n, i.wrapCallback(()=>{})), i.promise;
}
function fr(e, t) {
    cs("update", t, e._path, !1);
    const n = new C;
    return function(e, t, n, i) {
        Ls(e, "update", {
            path: t.toString(),
            value: n
        });
        let s = !0;
        const r = Is(e), o = {};
        if (pe(n, (n, i)=>{
            s = !1, o[n] = zi(Qe(t, n), Dt(i), e.serverSyncTree_, r);
        }), s) te("update() called with empty data.  Don't do anything."), Fs(0, i, "ok", void 0);
        else {
            const s = Ps(e), r = Ti(e.serverSyncTree_, t, o, s);
            ms(e.eventQueue_, r), e.server_.merge(t.toString(), n, (n, r)=>{
                const o = "ok" === n;
                o || re("update at " + t + " failed: " + n);
                const a = bi(e.serverSyncTree_, s, !o), l = a.length > 0 ? Ws(e, t) : t;
                vs(e.eventQueue_, l, a), Fs(0, i, n, r);
            }), pe(n, (n)=>{
                const i = Vs(e, Qe(t, n));
                Ws(e, i);
            }), vs(e.eventQueue_, t, []);
        }
    }(e._repo, e._path, t, n.wrapCallback(()=>{})), n.promise;
}
function gr(e) {
    e = A(e);
    const t = new Xs(()=>{}), n = new mr(t);
    return (function(e, t, n) {
        const i = Pi(e.serverSyncTree_, t);
        return null != i ? Promise.resolve(i) : e.server_.get(t).then((i)=>{
            const s = Dt(i).withIndex(t._queryParams.getIndex());
            let r;
            if (ki(e.serverSyncTree_, t, n, !0), t._queryParams.loadsAllData()) r = Ei(e.serverSyncTree_, t._path, s);
            else {
                const n = Oi(e.serverSyncTree_, t);
                r = Si(e.serverSyncTree_, t._path, s, n);
            }
            return vs(e.eventQueue_, t._path, r), Ii(e.serverSyncTree_, t, n, null, !0), s;
        }, (n)=>(Ls(e, "get for query " + E(t) + " failed: " + n), Promise.reject(new Error(n))));
    })(e._repo, e, n).then((t)=>new rr(t, new sr(e._repo, e._path), e._queryParams.getIndex()));
}
class mr {
    constructor(e){
        this.callbackContext = e;
    }
    respondsTo(e) {
        return "value" === e;
    }
    createEvent(e, t) {
        const n = t._queryParams.getIndex();
        return new Gs("value", this, new rr(e.snapshotNode, new sr(t._repo, t._path), n));
    }
    getEventRunner(e) {
        return "cancel" === e.getEventType() ? ()=>this.callbackContext.onCancel(e.error) : ()=>this.callbackContext.onValue(e.snapshot, null);
    }
    createCancelEvent(e, t) {
        return this.callbackContext.hasCancelCallback ? new Js(this, e, t) : null;
    }
    matches(e) {
        return e instanceof mr && (!e.callbackContext || !this.callbackContext || e.callbackContext.matches(this.callbackContext));
    }
    hasAnyCallback() {
        return null !== this.callbackContext;
    }
}
class yr {
    constructor(e, t){
        this.eventType = e, this.callbackContext = t;
    }
    respondsTo(e) {
        let t = "children_added" === e ? "child_added" : e;
        return t = "children_removed" === t ? "child_removed" : t, this.eventType === t;
    }
    createCancelEvent(e, t) {
        return this.callbackContext.hasCancelCallback ? new Js(this, e, t) : null;
    }
    createEvent(e, t) {
        a(null != e.childName, "Child events should have a childName.");
        const n = lr(new sr(t._repo, t._path), e.childName), i = t._queryParams.getIndex();
        return new Gs(e.type, this, new rr(e.snapshotNode, n, i), e.prevName);
    }
    getEventRunner(e) {
        return "cancel" === e.getEventType() ? ()=>this.callbackContext.onCancel(e.error) : ()=>this.callbackContext.onValue(e.snapshot, e.prevName);
    }
    matches(e) {
        return e instanceof yr && this.eventType === e.eventType && (!this.callbackContext || !e.callbackContext || this.callbackContext.matches(e.callbackContext));
    }
    hasAnyCallback() {
        return !!this.callbackContext;
    }
}
function vr(e, t, n, i, s) {
    let r;
    if ("object" == typeof i && (r = void 0, s = i), "function" == typeof i && (r = i), s && s.onlyOnce) {
        const t = n, i = (n, i)=>{
            As(e._repo, e, a), t(n, i);
        };
        i.userCallback = n.userCallback, i.context = n.context, n = i;
    }
    const o = new Xs(n, r || void 0), a = "value" === t ? new mr(o) : new yr(t, o);
    return function(e, t, n) {
        let i;
        i = ".info" === je(t._path) ? ki(e.infoSyncTree_, t, n) : ki(e.serverSyncTree_, t, n), ys(e.eventQueue_, t._path, i);
    }(e._repo, e, a), ()=>As(e._repo, e, a);
}
function Cr(e, t, n, i) {
    return vr(e, "value", t, n, i);
}
function wr(e, t, n, i) {
    return vr(e, "child_added", t, n, i);
}
function Tr(e, t, n, i) {
    return vr(e, "child_changed", t, n, i);
}
function br(e, t, n, i) {
    return vr(e, "child_moved", t, n, i);
}
function Er(e, t, n, i) {
    return vr(e, "child_removed", t, n, i);
}
function Ir(e, t, n) {
    let i = null;
    const s = n ? new Xs(n) : null;
    "value" === t ? i = new mr(s) : t && (i = new yr(t, s)), As(e._repo, e, i);
}
class Sr {
}
class kr extends Sr {
    constructor(e, t){
        super(), this._value = e, this._key = t;
    }
    _apply(e) {
        ls("endAt", this._value, e._path, !0);
        const t = Vt(e._queryParams, this._value, this._key);
        if (ir(t), nr(t), e._queryParams.hasEnd()) throw new Error("endAt: Starting point was already set (by another call to endAt, endBefore or equalTo).");
        return new er(e._repo, e._path, t, e._orderByCalled);
    }
}
function Nr(e, t) {
    return ds("endAt", "key", t, !0), new kr(e, t);
}
class Pr extends Sr {
    constructor(e, t){
        super(), this._value = e, this._key = t;
    }
    _apply(e) {
        ls("endBefore", this._value, e._path, !1);
        const t = function(e, t, n) {
            let i;
            return i = e.index_ === ht || n ? Vt(e, t, n) : Vt(e, t, ae), i.endBeforeSet_ = !0, i;
        }(e._queryParams, this._value, this._key);
        if (ir(t), nr(t), e._queryParams.hasEnd()) throw new Error("endBefore: Starting point was already set (by another call to endAt, endBefore or equalTo).");
        return new er(e._repo, e._path, t, e._orderByCalled);
    }
}
function xr(e, t) {
    return ds("endBefore", "key", t, !0), new Pr(e, t);
}
class Rr extends Sr {
    constructor(e, t){
        super(), this._value = e, this._key = t;
    }
    _apply(e) {
        ls("startAt", this._value, e._path, !0);
        const t = Ht(e._queryParams, this._value, this._key);
        if (ir(t), nr(t), e._queryParams.hasStart()) throw new Error("startAt: Starting point was already set (by another call to startAt, startBefore or equalTo).");
        return new er(e._repo, e._path, t, e._orderByCalled);
    }
}
function Dr(e = null, t) {
    return ds("startAt", "key", t, !0), new Rr(e, t);
}
class Ar extends Sr {
    constructor(e, t){
        super(), this._value = e, this._key = t;
    }
    _apply(e) {
        ls("startAfter", this._value, e._path, !1);
        const t = function(e, t, n) {
            let i;
            return i = e.index_ === ht || n ? Ht(e, t, n) : Ht(e, t, le), i.startAfterSet_ = !0, i;
        }(e._queryParams, this._value, this._key);
        if (ir(t), nr(t), e._queryParams.hasStart()) throw new Error("startAfter: Starting point was already set (by another call to startAt, startAfter, or equalTo).");
        return new er(e._repo, e._path, t, e._orderByCalled);
    }
}
function Or(e, t) {
    return ds("startAfter", "key", t, !0), new Ar(e, t);
}
class Lr extends Sr {
    constructor(e){
        super(), this._limit = e;
    }
    _apply(e) {
        if (e._queryParams.hasLimit()) throw new Error("limitToFirst: Limit was already set (by another call to limitToFirst or limitToLast).");
        return new er(e._repo, e._path, function(e, t) {
            const n = e.copy();
            return n.limitSet_ = !0, n.limit_ = t, n.viewFrom_ = "l", n;
        }(e._queryParams, this._limit), e._orderByCalled);
    }
}
function Fr(e) {
    if ("number" != typeof e || Math.floor(e) !== e || e <= 0) throw new Error("limitToFirst: First argument must be a positive integer.");
    return new Lr(e);
}
class Mr extends Sr {
    constructor(e){
        super(), this._limit = e;
    }
    _apply(e) {
        if (e._queryParams.hasLimit()) throw new Error("limitToLast: Limit was already set (by another call to limitToFirst or limitToLast).");
        return new er(e._repo, e._path, function(e, t) {
            const n = e.copy();
            return n.limitSet_ = !0, n.limit_ = t, n.viewFrom_ = "r", n;
        }(e._queryParams, this._limit), e._orderByCalled);
    }
}
function qr(e) {
    if ("number" != typeof e || Math.floor(e) !== e || e <= 0) throw new Error("limitToLast: First argument must be a positive integer.");
    return new Mr(e);
}
class Wr extends Sr {
    constructor(e){
        super(), this._path = e;
    }
    _apply(e) {
        tr(e, "orderByChild");
        const t = new Ue(this._path);
        if ($e(t)) throw new Error("orderByChild: cannot pass in empty path. Use orderByValue() instead.");
        const n = new At(t), i = zt(e._queryParams, n);
        return nr(i), new er(e._repo, e._path, i, !0);
    }
}
function Ur(e) {
    if ("$key" === e) throw new Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.');
    if ("$priority" === e) throw new Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.');
    if ("$value" === e) throw new Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.');
    return _s("orderByChild", "path", e, !1), new Wr(e);
}
class Br extends Sr {
    _apply(e) {
        tr(e, "orderByKey");
        const t = zt(e._queryParams, ht);
        return nr(t), new er(e._repo, e._path, t, !0);
    }
}
function jr() {
    return new Br;
}
class Hr extends Sr {
    _apply(e) {
        tr(e, "orderByPriority");
        const t = zt(e._queryParams, Tt);
        return nr(t), new er(e._repo, e._path, t, !0);
    }
}
function Vr() {
    return new Hr;
}
class zr extends Sr {
    _apply(e) {
        tr(e, "orderByValue");
        const t = zt(e._queryParams, Ot);
        return nr(t), new er(e._repo, e._path, t, !0);
    }
}
function Yr() {
    return new zr;
}
class Kr extends Sr {
    constructor(e, t){
        super(), this._value = e, this._key = t;
    }
    _apply(e) {
        if (ls("equalTo", this._value, e._path, !1), e._queryParams.hasStart()) throw new Error("equalTo: Starting point was already set (by another call to startAt/startAfter or equalTo).");
        if (e._queryParams.hasEnd()) throw new Error("equalTo: Ending point was already set (by another call to endAt/endBefore or equalTo).");
        return new kr(this._value, this._key)._apply(new Rr(this._value, this._key)._apply(e));
    }
}
function Qr(e, t) {
    return ds("equalTo", "key", t, !0), new Kr(e, t);
}
function $r(e, ...t) {
    let n = A(e);
    for (const e of t)n = e._apply(n);
    return n;
}
!function(e) {
    a(!oi, "__referenceConstructor has already been defined"), oi = e;
}(sr), function(e) {
    a(!ai, "__referenceConstructor has already been defined"), ai = e;
}(sr);
const Gr = {};
let Jr = !1;
function Xr(e, t, n, i, s) {
    let r = i || e.options.databaseURL;
    void 0 === r && (e.options.projectId || se("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp()."), te("Using default host for project ", e.options.projectId), r = `${e.options.projectId}-default-rtdb.firebaseio.com`);
    let o, a, l = Ys(r, s), h = l.repoInfo;
    "undefined" != typeof process && process.env && (a = undefined), a ? (o = !0, r = `http://${a}?ns=${h.namespace}`, l = Ys(r, s), h = l.repoInfo) : o = !l.repoInfo.secure;
    const c = s && o ? new Te(Te.OWNER) : new we(e.name, e.options, t);
    fs("Invalid Firebase Database URL", l), $e(l.path) || se("Database URL must point to the root of a Firebase Database (not including a child path).");
    const u = function(e, t, n, i) {
        let s = Gr[t.name];
        s || (s = {}, Gr[t.name] = s);
        let r = s[e.toURLString()];
        r && se("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.");
        return r = new Ts(e, Jr, n, i), s[e.toURLString()] = r, r;
    }(h, e, c, new Ce(e.name, n));
    return new Zr(u, e);
}
class Zr {
    constructor(e, t){
        this._repoInternal = e, this.app = t, this.type = "database", this._instanceStarted = !1;
    }
    get _repo() {
        return this._instanceStarted || (bs(this._repoInternal, this.app.options.appId, this.app.options.databaseAuthVariableOverride), this._instanceStarted = !0), this._repoInternal;
    }
    get _root() {
        return this._rootInternal || (this._rootInternal = new sr(this._repo, Be())), this._rootInternal;
    }
    _delete() {
        return null !== this._rootInternal && (!function(e, t) {
            const n = Gr[t];
            n && n[e.key] === e || se(`Database ${t}(${e.repoInfo_}) has already been deleted.`), Os(e), delete n[e.key];
        }(this._repo, this.app.name), this._repoInternal = null, this._rootInternal = null), Promise.resolve();
    }
    _checkNotDeleted(e) {
        null === this._rootInternal && se("Cannot call " + e + " on a deleted database.");
    }
}
function eo() {
    Le.IS_TRANSPORT_INITIALIZED && re("Transport has already been initialized. Please call this function before calling ref or setting up a listener");
}
function to() {
    eo(), Re.forceDisallow();
}
function no() {
    eo(), Oe.forceDisallow(), Re.forceAllow();
}
function io(n = (0, _firebaseApp.getApp)(), i) {
    const s = (0, _firebaseApp._getProvider)(n, "database").getImmediate({
        identifier: i
    });
    if (!s._instanceStarted) {
        const e = v("database");
        e && so(s, ...e);
    }
    return s;
}
function so(e, t, n, i = {}) {
    (e = A(e))._checkNotDeleted("useEmulator"), e._instanceStarted && se("Cannot call useEmulator() after instance has already been initialized.");
    const s = e._repoInternal;
    let r;
    if (s.repoInfo_.nodeAdmin) i.mockUserToken && se('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".'), r = new Te(Te.OWNER);
    else if (i.mockUserToken) {
        const t = "string" == typeof i.mockUserToken ? i.mockUserToken : function(e, t) {
            if (e.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
            const n = t || "demo-project", i = e.iat || 0, s = e.sub || e.user_id;
            if (!s) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
            const r = Object.assign({
                iss: `https://securetoken.google.com/${n}`,
                aud: n,
                iat: i,
                exp: i + 3600,
                auth_time: i,
                sub: s,
                user_id: s,
                firebase: {
                    sign_in_provider: "custom",
                    identities: {}
                }
            }, e);
            return [
                _(JSON.stringify({
                    alg: "none",
                    type: "JWT"
                })),
                _(JSON.stringify(r)),
                ""
            ].join(".");
        }(i.mockUserToken, e.app.options.projectId);
        r = new Te(t);
    }
    !function(e, t, n, i) {
        e.repoInfo_ = new Ee(`${t}:${n}`, !1, e.repoInfo_.namespace, e.repoInfo_.webSocketOnly, e.repoInfo_.nodeAdmin, e.repoInfo_.persistenceKey, e.repoInfo_.includeNamespaceInQueryParams, !0), i && (e.authTokenProvider_ = i);
    }(s, t, n, r);
}
function ro(e) {
    (e = A(e))._checkNotDeleted("goOffline"), Os(e._repo);
}
function oo(e) {
    var t;
    (e = A(e))._checkNotDeleted("goOnline"), (t = e._repo).persistentConnection_ && t.persistentConnection_.resume("repo_interrupt");
}
function ao(e, t) {
    ee(e, t);
}
const lo = {
    ".sv": "timestamp"
};
function ho() {
    return lo;
}
function co(e) {
    return {
        ".sv": {
            increment: e
        }
    };
}
class uo {
    constructor(e, t){
        this.committed = e, this.snapshot = t;
    }
    toJSON() {
        return {
            committed: this.committed,
            snapshot: this.snapshot.toJSON()
        };
    }
}
function _o(e, t, n) {
    var i;
    if (e = A(e), ps("Reference.transaction", e._path), ".length" === e.key || ".keys" === e.key) throw "Reference.transaction failed: " + e.key + " is a read-only object.";
    const s = null === (i = null == n ? void 0 : n.applyLocally) || void 0 === i || i, r = new C, o = Cr(e, ()=>{});
    return function(e, t, n, i, s, r) {
        Ls(e, "transaction on " + t);
        const o = {
            path: t,
            update: n,
            onComplete: i,
            status: null,
            order: $(),
            applyLocally: r,
            retryCount: 0,
            unwatcher: s,
            abortReason: null,
            currentWriteId: null,
            currentInputSnapshot: null,
            currentOutputSnapshotRaw: null,
            currentOutputSnapshotResolved: null
        }, l = Ms(e, t, void 0);
        o.currentInputSnapshot = l;
        const h = o.update(l.val());
        if (void 0 === h) o.unwatcher(), o.currentOutputSnapshotRaw = null, o.currentOutputSnapshotResolved = null, o.onComplete && o.onComplete(null, !1, o.currentInputSnapshot);
        else {
            hs("transaction failed: Data returned ", h, o.path), o.status = 0;
            const n = $i(e.transactionQueueTree_, t), i = Gi(n) || [];
            let s;
            i.push(o), Ji(n, i), "object" == typeof h && null !== h && S(h, ".priority") ? (s = k(h, ".priority"), a(as(s), "Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.")) : s = (Ni(e.serverSyncTree_, t) || xt.EMPTY_NODE).getPriority().val();
            const r = Is(e), c = Dt(h, s), u = Yi(c, l, r);
            o.currentOutputSnapshotRaw = c, o.currentOutputSnapshotResolved = u, o.currentWriteId = Ps(e);
            const d = wi(e.serverSyncTree_, t, u, o.currentWriteId, o.applyLocally);
            vs(e.eventQueue_, t, d), qs(e, e.transactionQueueTree_);
        }
    }(e._repo, e._path, t, (t, n, i)=>{
        let s = null;
        t ? r.reject(t) : (s = new rr(i, new sr(e._repo, e._path), Tt), r.resolve(new uo(n, s)));
    }, o, s), r.promise;
}
st.prototype.simpleListen = function(e, t) {
    this.sendRequest("q", {
        p: e
    }, t);
}, st.prototype.echo = function(e, t) {
    this.sendRequest("echo", {
        d: e
    }, t);
};
const po = function(e) {
    const t = st.prototype.put;
    return st.prototype.put = function(n, i, s, r) {
        void 0 !== r && (r = e()), t.call(this, n, i, s, r);
    }, function() {
        st.prototype.put = t;
    };
}, fo = function(e) {
    !function(e) {
        Jr = e;
    }(e);
};
var go;
j((0, _firebaseApp.SDK_VERSION)), (0, _firebaseApp._registerComponent)(new O("database", (e, { instanceIdentifier: t  })=>Xr(e.getProvider("app").getImmediate(), e.getProvider("auth-internal"), e.getProvider("app-check-internal"), t), "PUBLIC").setMultipleInstances(!0)), (0, _firebaseApp.registerVersion)(U, "0.14.4", go), (0, _firebaseApp.registerVersion)(U, "0.14.4", "esm2017");

},{"e4246be5acb84c55":"d5jf4","/scripts/firebaseApp":"fvEBi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["aid5L","9UgBq"], "9UgBq", "parcelRequireedb4")

</script>

    <script src="/index.af5ea236.js" defer=""></script>
  </body>
</html>
